(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],2:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * app.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

var _routes = require("./routes");

var _drumMachineController = require("./components/drum-machine/drumMachineController");

var _testController = require("./components/test/testController");

var _trackDirective = require("./directives/trackDirective");

var _tickSliderDirective = require("./directives/tickSliderDirective");

var _commentDirective = require("./directives/commentDirective");

var _savePresetDirective = require("./directives/savePresetDirective");

var _loadSamples = require("./directives/loadSamples");

require("regenerator-runtime/runtime");

(function () {
  var app = angular.module("myApp", ["ngRoute", "ngFileSaver", "ngSanitize", "ui.select"]); // configure angular routes

  app.config(["$routeProvider", _routes.initRoutes]); // bind controllers

  app.controller("drumMachineController", ["$scope", "$compile", "$http", "$interval", "serverBaseURL", "FileSaver", "Blob", "socketEvents", _drumMachineController.drumMachineController]);
  app.controller("testController", ['$scope', _testController.testController]); // register directives

  app.directive("tickSlider", _tickSliderDirective.tickSliderDirective);
  app.directive("theTrack", ["$http", "$compile", "supportedAudioFormats", _trackDirective.trackDirective]);
  app.directive("comment", _commentDirective.commentDirective);
  app.directive("savePreset", _savePresetDirective.savePresetDirective);
  app.directive("loadSamples", ["$http", "supportedAudioFormats", _loadSamples.loadSamples]);
  var supportedAudioFormats = new Set();
  supportedAudioFormats.add("wav");
  supportedAudioFormats.add("audio/wav");
  supportedAudioFormats.add("audio/x-wav");
  supportedAudioFormats.add("mp3");
  supportedAudioFormats.add("audio/mp3");
  supportedAudioFormats.add("audio/x-mp3");
  supportedAudioFormats.add("ogg");
  supportedAudioFormats.add("audio/ogg");
  supportedAudioFormats.add("audio/x-ogg");
  var socketEvents = {
    newPreset: "NEW_PRESET",
    newComment: "NEW_COMMENT"
  }; // constants

  app.constant("serverBaseURL", "http://localhost:4500");
  app.constant("supportedAudioFormats", supportedAudioFormats);
  app.constant("socketEvents", socketEvents);
})();

},{"./components/drum-machine/drumMachineController":8,"./components/test/testController":9,"./directives/commentDirective":10,"./directives/loadSamples":11,"./directives/savePresetDirective":12,"./directives/tickSliderDirective":13,"./directives/trackDirective":14,"./routes":15,"regenerator-runtime/runtime":1}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrumMachine = void 0;

var _audioLoader = require("./audio-loader");

var _utils = require("../utils/utils");

var _Track = require("./Track");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DrumMachine =
/*#__PURE__*/
function () {
  function DrumMachine() {
    _classCallCheck(this, DrumMachine);

    this.tag = "[DrumMachine.js]";
    this.numberOfBeats = 16;
    var AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new AudioContext();
    this.pannerNodeSupported = false;
    this.bpm = 120;
    this.bpmMin = 30;
    this.bpmMax = 240;
    this.timeSignature = {
      num: 4,
      den: 4
    };
    this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note

    this.isPlaying = false;
    this.isStopped = true;
    this.buffers = {};
    this.tracks = {}; // this.defaultBuffersLoaded = false;
    // this.defaultTracksLoaded = false;

    this._tracksInSolo = new Set();
    this._tracksInMute = new Set();
    this.currentTickIndex = 0;
    this.callBacksInLoop = [];
    this.soundURLs = {
      kick: "app/assets/audio/kick.wav",
      snare: "app/assets/audio/snare.wav",
      hat: "app/assets/audio/hat.wav",
      ride: "app/assets/audio/ride.wav"
    };

    if ((0, _utils.checkIfiOSdevice)()) {
      this._enableAudioContextForiOS();
    } else {
      this.audioContextEnabled = true;
    }

    if (typeof this.audioContext.createStereoPanner === "function") {
      this.pannerNodeSupported = true;
      console.log("Stereo panner supported");
    } else {
      console.log("Stereo panner not supported");
    }
  }
  /*
   * get bpm
   */


  _createClass(DrumMachine, [{
    key: "_enableAudioContextForiOS",
    value: function _enableAudioContextForiOS() {
      var _this = this;

      $(document).ready(function () {
        var btn = $("<button/>", {
          visibility: "hidden"
        });
        btn.on("touchstart", function () {
          var buffer = _this.audioContext.createBuffer(1, 1, 22050);

          var source = _this.audioContext.createBufferSource();

          source.buffer = buffer;
          source.start();
          _this.audioContextEnabled = true;
          console.log("AudioContext enabled for iOS");
        });
        btn.trigger("touchstart");
      });
    }
    /*
    _loadDefaultBuffers() {
         let ctx = this.audioContext;
        let urls = this.soundURLs;
         return new Promise((resolve, reject) => {
            Promise.all([
                audioLoader(ctx, urls.kick),
                audioLoader(ctx, urls.snare),
                audioLoader(ctx, urls.hat),
                audioLoader(ctx, urls.ride)
            ]).then(values => {
                this.buffers["kick"] = values[0];
                this.buffers["snare"] = values[1];
                this.buffers["hat"] = values[2];
                this.buffers["ride"] = values[3];
                this.defaultBuffersLoaded = true;
                console.log(this.buffers);
                 this.defaultBuffersLoaded = true;
                console.log("Default buffers loaded");
                // this._initDefaultTracks();
                 resolve("Default buffers loaded");
             }, error => {
                reject(error);
            });
        });
    }
      _initDefaultTracks() {
         if (!this.defaultBuffersLoaded) {
            return;
        }
         this.tracks = {};
         let kickTrack = new Track(this, "kick", this.buffers["kick"]);
        kickTrack.setTicksFromArray([0,4,8,12]);
        let snareTrack = new Track(this, "snare", this.buffers["snare"], 1, 0.1);
        snareTrack.setTicksFromArray([4,12]);
        let hatTrack = new Track(this, "hat", this.buffers["hat"], 0.85, -1);
        // hatTrack.setTicksFromArray([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
          hatTrack.setTicksFromArray([
            {
                active: true,
                index: 0,
                volume: 0.5
            },
            {
                active: true,
                index: 1,
                volume: 0.5
            },
            {
                active: true,
                index: 2,
                volume: 1.2
            },
            {
                active: true,
                index: 3,
                volume: 0.4
            },
            {
                active: true,
                index: 4,
                volume: 0.9
            },
            {
                active: true,
                index: 5,
                volume: 0.5
            },
            {
                active: true,
                index: 6,
                volume: 1
            },
            {
                active: true,
                index: 7,
                volume: 0.4
            },
            {
                active: true,
                index: 8,
                volume: 0.9
            },
            {
                active: true,
                index: 9,
                volume: 0.5
            },
            {
                active: true,
                index: 10,
                volume: 1
            },
            {
                active: true,
                index: 11,
                volume: 0.4
            },
            {
                active: true,
                index: 12,
                volume: 0.9
            },
            {
                active: true,
                index: 13,
                volume: 0.5
            },
            {
                active: true,
                index: 14,
                volume: 1
            },
            {
                active: true,
                index: 15,
                volume: 0.4
            }
        ]);
         this.tracks[kickTrack.id] = kickTrack;
        this.tracks[snareTrack.id] = snareTrack;
        this.tracks[hatTrack.id] = hatTrack;
         this.defaultTracksLoaded = true;
        console.log("Default tracks loaded" , this.tracks);
         // this._start();
    }
    */

  }, {
    key: "_onBpmChanged",
    value: function _onBpmChanged() {
      this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note
    }
  }, {
    key: "_start",
    value: function _start() {
      if (!this.audioContextEnabled) {
        console.log("Cannot play: AudioContext is not enabled.");
        return;
      }

      if (this.isPlaying) {
        console.log("Cannot play: it is already playing.");
        return;
      }

      this.isStopped = false;
      var self = this;
      var ctx = this.audioContext;
      var startTime = ctx.currentTime;
      var nextTickTime = startTime + self.tickTime;
      var index = 0;
      var timeOutID;
      var firstLoopEnded = false;

      function scheduler() {
        if (self.isStopped) {
          clearTimeout(timeOutID);
          self.isPlaying = false;
          return;
        }

        if (nextTickTime <= ctx.currentTime + self.tickTime) {
          self.isPlaying = true;
          self.isStopped = false;
          $.each(self.tracks, function (id, track) {
            if (track.mute) {
              return;
            }

            if (!track.sampleData.decodedAudioBuffer) {
              return;
            }

            var trackTick = track.ticks[index];

            if (!trackTick.active) {
              return;
            }

            var tickSound = ctx.createBufferSource();
            tickSound.buffer = track.sampleData.decodedAudioBuffer;
            var tickGainNode = ctx.createGain();
            tickSound.connect(tickGainNode);
            tickGainNode.gain.value = trackTick.volume;
            tickGainNode.connect(track.gainNode);
            tickSound.start(nextTickTime);
          });
          self.currentTickIndex = index;
          var previousIndex = index === 0 ? self.numberOfBeats - 1 : index - 1;
          var previousPrevious = previousIndex === 0 ? self.numberOfBeats - 1 : previousIndex - 1; // to syncronize web audio api schedule with ui beat indicators

          if (firstLoopEnded) {
            self.callBacksInLoop.forEach(function (fn) {
              fn(previousPrevious, previousIndex);
            });
          }

          nextTickTime += self.tickTime;
          index = ++index === self.numberOfBeats ? 0 : index;
        }

        firstLoopEnded = true;
        timeOutID = window.setTimeout(scheduler, 0);
      }

      scheduler();
    }
  }, {
    key: "_stop",
    value: function _stop() {
      this.isStopped = true;
    }
  }, {
    key: "_playSound",
    value: function _playSound(bufferName, time) {
      var ctx = this.audioContext;
      var sound = ctx.createBufferSource();
      sound.buffer = this.buffers[bufferName];
      sound.connect(ctx.destination);
      sound.start(time);
    }
  }, {
    key: "playSoundFromBuffer",
    value: function playSoundFromBuffer(buffer, time) {
      if (!buffer) return;
      var ctx = this.audioContext;
      var sound = ctx.createBufferSource();
      sound.buffer = buffer;
      sound.connect(ctx.destination);

      if (time) {
        sound.start(time);
      } else {
        sound.start();
      }
    }
  }, {
    key: "removeTrack",
    value: function removeTrack(trackID) {
      var track = this.tracks[trackID];

      this._tracksInSolo["delete"](track);

      this._tracksInMute["delete"](track);

      delete this.tracks[trackID];
    }
  }, {
    key: "soloTrack",
    value: function soloTrack(trackID) {
      if (!this.tracks.hasOwnProperty(trackID)) return;
      var focusTrack = this.tracks[trackID];
      var tracksInSolo = this._tracksInSolo;
      var tracksInMute = this._tracksInMute; // case 1: track is not in solo and not in mute

      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {
        tracksInSolo.add(focusTrack);
        focusTrack.solo = true;
        focusTrack.mute = false;
        $.each(this.tracks, function (id, track) {
          if (id === trackID) {
            return;
          }

          if (!tracksInSolo.has(track)) {
            tracksInMute.add(track);
            track.mute = true;
            track.solo = false;
          }
        });
      } // case 2: track is in solo
      else if (tracksInSolo.has(focusTrack)) {
          tracksInSolo["delete"](focusTrack);
          focusTrack.solo = false;

          if (tracksInSolo.size > 0) {
            tracksInMute.add(focusTrack);
            focusTrack.mute = true;
          } else {
            tracksInMute.clear();
            tracksInSolo.clear();
            $.each(this.tracks, function (id, track) {
              track.mute = false;
              track.solo = false;
            });
          }
        } // case 3: track is in mute
        else {
            tracksInSolo.add(focusTrack);
            focusTrack.solo = true;
            focusTrack.mute = false;

            if (tracksInSolo.size === 1) {
              $.each(this.tracks, function (id, track) {
                if (id !== trackID) {
                  tracksInMute.add(track);
                  track.mute = true;
                }
              });
            }
          }
    }
  }, {
    key: "muteTrack",
    value: function muteTrack(trackID) {
      if (!this.tracks.hasOwnProperty(trackID)) return;
      var focusTrack = this.tracks[trackID];
      var tracksInSolo = this._tracksInSolo;
      var tracksInMute = this._tracksInMute; // case 1: track not in solo or mute

      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {
        tracksInMute.add(focusTrack);
        focusTrack.mute = true;
        focusTrack.solo = false;
      } // case 2: track is in solo
      else if (tracksInSolo.has(focusTrack)) {
          tracksInSolo["delete"](focusTrack);
          tracksInMute.add(focusTrack);
          focusTrack.solo = false;
          focusTrack.mute = true;

          if (tracksInSolo.size === 0) {
            $.each(this.tracks, function (id, track) {
              if (id !== trackID) {
                tracksInMute["delete"](track);
                track.mute = false;
              }
            });
          }
        } // case 3: track is in mute
        else if (tracksInMute.has(focusTrack)) {
            if (tracksInSolo.size > 0) {
              tracksInMute["delete"](focusTrack);
              tracksInSolo.add(focusTrack);
              focusTrack.mute = false;
              focusTrack.solo = true;
            } else {
              tracksInMute["delete"](focusTrack);
              focusTrack.mute = false;
            }
          }
    }
  }, {
    key: "addCallBackInLoop",
    value: function addCallBackInLoop(fn) {
      if (!_typeof(fn) === "function") return;
      this.callBacksInLoop.push(fn);
    }
  }, {
    key: "isInRangeBPM",
    value: function isInRangeBPM(value) {
      if (value >= this.bpmMin && value <= this.bpmMax) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "_createEmptyTicksArray",
    value: function _createEmptyTicksArray() {
      var ticks = [];

      for (var i = 0; i < this.numberOfBeats; i++) {
        ticks.push({
          index: i,
          volume: 0,
          active: false
        });
      }

      return ticks;
    }
  }, {
    key: "_clearTracks",
    value: function _clearTracks() {
      this._tracksInSolo.clear();

      this._tracksInMute.clear();

      for (var key in this.tracks) {
        if (this.tracks.hasOwnProperty(key)) {
          delete this.tracks[key];
        }
      }
    }
  }, {
    key: "addEmptyTrack",
    value: function addEmptyTrack() {
      var name = "track_" + (Object.keys(this.tracks).length + 1);
      var track = new _Track.Track(this, name);
      track.setTicksFromArray(this._createEmptyTicksArray());
      this.tracks[track.id] = track;
    }
  }, {
    key: "createTrack",
    value: function createTrack(name, soundPath, volume, pan, ticks) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var track = new _Track.Track(_this2, name, soundPath);

        if (ticks) {
          track.setTicksFromArray(ticks);
        } else {
          track.setTicksFromArray(_this2._createEmptyTicksArray());
        }

        if (volume) {
          track.gainNode.gain.value = volume;
        }

        if (pan) {
          if (track.pannerNode) {
            track.pannerNode.pan.value = pan;
          }
        }

        resolve(track);
      });
    }
  }, {
    key: "loadPreset",
    value: function loadPreset(data) {
      var _this3 = this;

      try {
        this.bpm = data.bpm;

        this._clearTracks();

        var promises = [];
        data.tracks.forEach(function (track) {
          promises.push(_this3.createTrack(track.name, track.soundPath, track.volume, track.pan, track.ticks));
        });
        return Promise.all(promises);
      } catch (e) {
        return new Promise(function (resolve, reject) {
          reject(e);
        });
      }
    }
  }, {
    key: "buildJsonPreset",
    value: function buildJsonPreset(name, category) {
      var _this4 = this;

      var data = {
        name: name,
        category: category,
        bpm: this.bpm,
        timeSignature: this.timeSignature
      };
      var tracks = [];

      for (var id in this.tracks) {
        if (this.tracks.hasOwnProperty(id)) {
          (function () {
            var track = _this4.tracks[id];
            var trackData = {
              name: track.name,
              soundPath: category + "/" + track.sampleData.fileName,
              volume: track.gainNode.gain.value,
              pan: _this4.pannerNodeSupported ? track.pannerNode.pan.value : 0
            };
            var ticksData = [];
            track.ticks.forEach(function (tick) {
              ticksData.push({
                active: tick.active,
                index: tick.index,
                volume: tick.volume
              });
            });
            trackData.ticks = ticksData;
            tracks.push(trackData);
          })();
        }
      }

      data.tracks = tracks;
      return JSON.stringify(data);
    }
  }, {
    key: "bpm",
    get: function get() {
      return this._bpm;
    }
    /*
     * set bpm
     */
    ,
    set: function set(val) {
      if (val !== this._bpm) {
        this._bpm = val;

        this._onBpmChanged();
      }
    }
  }]);

  return DrumMachine;
}();

exports.DrumMachine = DrumMachine;

},{"../utils/utils":16,"./Track":5,"./audio-loader":6}],4:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * Tick.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tick = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tick = function Tick() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

  _classCallCheck(this, Tick);

  this.index = index;
  this.active = active;
  this.volume = volume;
} // get volume() {
//     return this._volume;
// }
//
// set volume(val) {
//     this._volume = val > 1 ? 1.0 : val;
// }
;

exports.Tick = Tick;

},{}],5:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * Track.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Track = void 0;

var _Tick = require("./Tick");

var _utils = require("../utils/utils");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Track =
/*#__PURE__*/
function () {
  function Track(drumMachine) {
    var _this = this;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "track_default";
    var soundPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;
    var pan = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var mute = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, Track);

    this.id = (0, _utils.guid)();
    this.drumMachine = drumMachine;
    this.audioContext = drumMachine.audioContext;
    this.name = name;
    this.sampleData = {
      fileName: "",
      extension: "",
      originalBuffer: undefined,
      decodedAudioBuffer: undefined
    };
    this.solo = false;
    this.mute = mute;
    this.ticks = [];
    this.pannerNodeSupported = false;
    this.gainNode = this.audioContext.createGain();
    this.gainNode.gain.value = volume;

    if (drumMachine.pannerNodeSupported) {
      this.pannerNode = this.audioContext.createStereoPanner();
      this.pannerNode.pan.value = pan;
      this.gainNode.connect(this.pannerNode);
      this.pannerNode.connect(this.audioContext.destination);
      this.pannerNodeSupported = true;
    } else {
      this.gainNode.connect(this.audioContext.destination);
    }

    if (soundPath) {
      (0, _utils.getArrayAudioBufferFromUrl)(this.audioContext, soundPath).then(function (buffer) {
        var fileName = (0, _utils.getFileNameFromPath)(soundPath);

        _this.setSampleData(fileName, buffer);
      });
    }

    this._initTicks();
  } // setGain(val) {
  //     this.gainNode.gain.value = val > 1 ? 1.0 : val;
  // }
  // setPan(val) {
  //     if (val < -1) {
  //         this.pannerNode.pan.value = -1;
  //     }
  //     else if (val > 1) {
  //         this.pannerNode.pan.value = 1;
  //     }
  //     else {
  //         this.pannerNode.pan.value = val;
  //     }
  // }

  /*
   *
   */


  _createClass(Track, [{
    key: "_initTicks",
    value: function _initTicks() {
      this.ticks = [];

      for (var i = 0; i < this.drumMachine.numberOfBeats; ++i) {
        this.ticks.push(new _Tick.Tick(i));
      }
    }
  }, {
    key: "setTick",
    value: function setTick(index) {
      var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

      if (index < 0 || index > this.drumMachine.numberOfBeats - 1) {
        return;
      }

      this.ticks[index].volume = volume;
      this.ticks[index].active = active;
    }
  }, {
    key: "setTicksFromArray",
    value: function setTicksFromArray(data) {
      var _this2 = this;

      data.forEach(function (e) {
        if (_typeof(e) === "object") {
          if (e.index === "undefined" || e.index < 0 || e.index > _this2.drumMachine.numberOfBeats - 1) {
            return;
          }

          _this2.ticks[e.index].volume = e.volume !== "undefined" ? e.volume : 0;
          _this2.ticks[e.index].active = e.active !== "undefined" ? e.active : false;
        } else {
          _this2.ticks[e].active = true;
        }
      });
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(arrayBuffer, fileName) {
      var _this3 = this;

      this.originalBuffer = arrayBuffer;
      this.drumMachine.audioContext.decodeAudioData(arrayBuffer, function (decodedAudioBuffer) {
        _this3.buffer = decodedAudioBuffer;
        console.log("Track " + _this3.name + ": audio buffer changed ( " + fileName + " )");
      });
    }
  }, {
    key: "playLoadedSample",
    value: function playLoadedSample() {
      if (!this.audioContext || !this.sampleData.decodedAudioBuffer) return;
      var sound = this.audioContext.createBufferSource();
      sound.buffer = this.sampleData.decodedAudioBuffer;
      sound.connect(this.audioContext.destination);
      sound.start();
    }
  }, {
    key: "setSampleData",
    value: function setSampleData(fileName, arrayAudioBuffer) {
      var _this4 = this;

      if (!fileName || !arrayAudioBuffer) {
        console.log("Missing fileName and/or arrayAudioBuffer parameters");
        return;
      }

      this.drumMachine.audioContext.decodeAudioData(arrayAudioBuffer, function (decodedBuffer) {
        _this4.sampleData.fileName = fileName;
        _this4.sampleData.extension = (0, _utils.getExtensionFromFileName)(fileName);
        _this4.sampleData.originalBuffer = arrayAudioBuffer;
        _this4.sampleData.decodedAudioBuffer = decodedBuffer;
      });
    }
  }]);

  return Track;
}();

exports.Track = Track;

},{"../utils/utils":16,"./Tick":4}],6:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * audio-loader.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.audioLoader = audioLoader;
exports.getArrayBuffer = getArrayBuffer;

function audioLoader(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      try {
        audioCtx.decodeAudioData(xhr.response, function (decodedBuffer) {
          resolve(decodedBuffer);
        });
      } catch (e) {
        reject(e);
      }
    };

    xhr.send();
  });
}

function getArrayBuffer(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      resolve(xhr.response);
    };

    xhr.send();
  });
}

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.psyTrancePreset = exports.groovyRockPreset = void 0;

/**
 * ---------------------------------------------------------------------------------------
 * presets.js
 * ---------------------------------------------------------------------------------------
 */
var groovyRockPreset = {
  name: "Straight rock",
  bpm: 120,
  category: "rock",
  timeSignature: {
    num: 4,
    den: 4
  },
  tracks: [{
    name: "kick",
    soundPath: "app/assets/samples/rock/rock-kick.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 0,
      volume: 1
    }, {
      active: true,
      index: 8,
      volume: 1
    }, {
      active: true,
      index: 10,
      volume: 1
    }]
  }, {
    name: "snare",
    soundPath: "app/assets/samples/rock/rock-snare.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "hh open",
    soundPath: "app/assets/samples/rock/rock-hh-open.wav",
    volume: 0.4,
    pan: 0.4,
    ticks: [{
      active: true,
      index: 4,
      volume: 0.8
    }, {
      active: true,
      index: 8,
      volume: 0.8
    }, {
      active: true,
      index: 12,
      volume: 0.8
    }]
  }, {
    name: "crash",
    soundPath: "app/assets/samples/rock/rock-crash.wav",
    volume: 0.5,
    pan: -0.5,
    ticks: [{
      active: true,
      index: 0,
      volume: 0.8
    }]
  }]
};
exports.groovyRockPreset = groovyRockPreset;
var psyTrancePreset = {
  name: "psy-trance",
  category: "trance",
  bpm: 145,
  timeSignature: {
    num: 4,
    den: 4
  },
  tracks: [{
    name: "kick",
    soundPath: "app/assets/samples/trance/trance-kick.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 0,
      volume: 1
    }, {
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 8,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "clap",
    soundPath: "app/assets/samples/trance/trance-clap.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "hh open",
    soundPath: "app/assets/samples/trance/trance-hh-open.wav",
    volume: 0.8,
    pan: 0.2,
    ticks: [{
      active: true,
      index: 2,
      volume: 0.8
    }, {
      active: true,
      index: 6,
      volume: 0.8
    }, {
      active: true,
      index: 10,
      volume: 0.8
    }, {
      active: true,
      index: 14,
      volume: 0.8
    }]
  }, {
    name: "bass",
    soundPath: "app/assets/samples/trance/trance-bass-A1.wav",
    volume: 0.8,
    pan: 0,
    ticks: [{
      active: true,
      index: 1,
      volume: 0.8
    }, {
      active: true,
      index: 2,
      volume: 0.8
    }, {
      active: true,
      index: 3,
      volume: 0.8
    }, {
      active: true,
      index: 5,
      volume: 0.8
    }, {
      active: true,
      index: 6,
      volume: 0.8
    }, {
      active: true,
      index: 7,
      volume: 0.8
    }, {
      active: true,
      index: 9,
      volume: 0.8
    }, {
      active: true,
      index: 10,
      volume: 0.8
    }, {
      active: true,
      index: 11,
      volume: 0.8
    }, {
      active: true,
      index: 13,
      volume: 0.8
    }, {
      active: true,
      index: 14,
      volume: 0.8
    }, {
      active: true,
      index: 15,
      volume: 0.8
    }]
  }]
};
exports.psyTrancePreset = psyTrancePreset;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drumMachineController = drumMachineController;

var _DrumMachine = require("../../audio/DrumMachine");

var _audioLoader = require("../../audio/audio-loader");

var _presets = require("../../audio/presets");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function drumMachineController($scope, $compile, $http, $interval, serverBaseURL, FileSaver, Blob, socketEvents) {
  var drumMachine = new _DrumMachine.DrumMachine();
  var loadingContainer = $("#loadingContainer");
  var commentsLoadingOverlay = $("#commentsLoadingOverlay");
  var commentsLoadingSpinner = $("#commentsLoadingSpinner");
  var playBtn = $("#sequencerPlayButton");
  var stopBtn = $("#sequencerStopButton");
  var bpmSlider = $("#sequencerBPMslider");

  $scope.safeApply = function (fn) {
    var phase = this.$root.$$phase;

    if (phase == '$apply' || phase == '$digest') {
      if (fn && typeof fn === 'function') {
        fn();
      }
    } else {
      this.$apply(fn);
    }
  };

  $scope.title = "Main Controller";
  $scope.tracks = [];
  $scope.ticksElements = [];
  $scope.audioContext = drumMachine.audioContext;
  $scope.bpm = drumMachine.bpm;
  $scope.isPlaying = drumMachine.isPlaying;
  $scope.isStopped = drumMachine.isStopped;
  $scope.removeTrack = removeTrack;
  $scope.integerval = /^\d*$/;
  $scope.beats = new Array(drumMachine.numberOfBeats).fill(false);
  $scope.samplesData = {};
  $scope.samplesBuffers = {};
  $scope.username = "";
  $scope.commentToPost = "";
  $scope.comments = [];
  $scope.invalidUsernameMessage = "Give ya a name! (3-32 characters)";
  $scope.invalidCommentMessage = "Write something cool! (3-1000 characters)";
  $scope.preset = {
    name: "",
    categorySelected: undefined,
    categories: []
  };
  $scope.tracks = drumMachine.tracks;
  $scope.safeApply();
  /*
   * ---------------------------------------------------------------------------------------
   * UI
   * ---------------------------------------------------------------------------------------
   */

  $("#accordion").accordion({
    animate: 200,
    collapsible: true,
    active: false,
    heightStyle: "content",
    // icons: { "header": "ui-icon-plus", "activeHeader": "ui-icon-minus" },
    beforeActivate: function beforeActivate() {
      if ($scope.comments.length === 0) {
        loadComments();
      }
    }
  });
  $("#postCommentBtn").button({
    icon: "ui-icon-pencil"
  });
  /*
   * ---------------------------------------------------------------------------------------
   * event listeners
   * ---------------------------------------------------------------------------------------
   */

  $(window).ready(function () {
    var beatIndicatorsContainer = document.getElementById("beatIndicators");
    var beatIndicators = beatIndicatorsContainer.getElementsByClassName("beat-indicator");

    function updateBeatIndicators(previousTickIndex, tickIndex) {
      $(beatIndicators[previousTickIndex]).removeClass("beat-indicator-active");
      $(beatIndicators[tickIndex]).addClass("beat-indicator-active");
    }

    drumMachine.addCallBackInLoop(updateBeatIndicators);
  });
  window.addEventListener("keyup", function (e) {
    switch (e.keyCode) {
      //space
      case 32:
        if ($('textarea#commentArea, input#usernameInput, input[name="trackName"], input[name="presetName"]').is(":focus")) {
          e.stopPropagation();
        } else if ($scope.isStopped) {
          play(e);
        } else {
          stop(e);
        }

        break;

      default:
        break;
    }
  });
  window.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      //space
      case 32:
        if ($('textarea#commentArea, input#usernameInput, input[name="trackName"], input[name="presetName"]').is(":focus")) {
          e.stopPropagation();
        } else {
          e.preventDefault();
          e.stopPropagation();
        }

        break;

      default:
        break;
    }
  });
  window.addEventListener('keydown', function (e) {
    if (e.keyCode === 32 && e.target === document.body) {
      e.preventDefault();
    }
  }); // remove scroll down on spacebar

  /*
   * ---------------------------------------------------------------------------------------
   * public
   * ---------------------------------------------------------------------------------------
   */

  $scope.enableLoadingSpinner = enableLoadingSpinner;
  $scope.disableLoadingSpinner = disableLoadingSpinner;
  $scope.audioLoader = _audioLoader.audioLoader;
  $scope.playSoundFromBuffer = drumMachine.playSoundFromBuffer;

  $scope.startSequencer = function () {
    drumMachine._start();

    $scope.isPlaying = true;
    $scope.isStopped = false;
  };

  $scope.stopSequencer = function () {
    drumMachine._stop();

    $scope.isPlaying = false;
    $scope.isStopped = true;
    var indicators = document.getElementById("beatIndicators").getElementsByClassName("beat-indicator");
    $(indicators).removeClass("beat-indicator-active");
  };

  $scope.addTrack = function () {
    drumMachine.addEmptyTrack();
  };

  $scope.exportMidi = function () {
    var tracks = [];

    for (var key in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(key)) {
        (function () {
          var track = drumMachine.tracks[key];
          var trackData = {
            name: track.name,
            notes: []
          };
          var waitCounter = 0;
          track.ticks.forEach(function (tick) {
            if (tick.active) {
              var noteEventData = {
                pitch: ["C4"],
                velocity: tick.volume,
                duration: "16" // 1/16

              };

              if (waitCounter > 0) {
                var waitParam = "T" + waitCounter * 32; //number of ticks to wait (each tick is 1/128)

                noteEventData["wait"] = waitParam;
              }

              trackData.notes.push(noteEventData);
              waitCounter = 0;
            } else {
              waitCounter += 1;
            }
          });
          tracks.push(trackData);
        })();
      }
    }

    var data = {
      bpm: drumMachine.bpm,
      timeSignature: {
        num: 4,
        den: 4
      },
      tracks: tracks
    };
    $http({
      url: serverBaseURL + '/api/midi',
      method: "POST",
      responseType: "arraybuffer",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(data)
    }).then(function (response) {
      console.log(response);
      var blob = new Blob([response.data], {
        type: 'audio/midi'
      }); // let fileName = response.headers('content-disposition');

      FileSaver.saveAs(blob, "loop.mid");
    }, function (response) {
      console.log(response);
    });
  };

  $scope.populateCategories = function () {
    return new Promise(function (resolve, reject) {
      $http({
        url: serverBaseURL + "/api/categories",
        method: "GET",
        headers: {
          "Accept": "application/json"
        }
      }).then(function (response) {
        // console.log(response);
        var categories = response.data; // categories.forEach(c => {
        //     $scope.categories.push(c.name);
        // });

        $scope.preset.categories = categories;
        resolve(categories);
      }, function (error) {
        console.log(error);
        reject(error);
      });
    });
  };
  /*
  $scope.loadPreset = () => {
       $http({
          url: serverBaseURL + "/api/presets",
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      }).then(response => {
           let presets = response.data;
          if (presets.length === 0) {
              return;
          }
           drumMachine.loadPreset(presets[0]).then(tracks => {
               tracks.forEach(t => {
                  drumMachine.tracks[t.id] = t;
              });
               $scope.bpm = drumMachine.bpm;
              bpmSlider.slider("value", $scope.bpm);
              $scope.$apply();
            }, error => {
              console.log(error);
          });
       }, errorResponse => {
          console.log(errorResponse);
      });
   };
  */


  $scope.savePreset = function () {
    var formData = new FormData();
    var jsonPreset = drumMachine.buildJsonPreset($scope.preset.name, $scope.preset.categorySelected.name);

    for (var id in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(id)) {
        var track = drumMachine.tracks[id];
        var blob = new Blob([track.sampleData.originalBuffer], {
          // type: track.sampleData.extension ? "audio/" + track.sampleData.extension : "octet-stream"
          type: "octet-stream"
        });
        formData.append("sample", blob, track.sampleData.fileName);
      }
    }

    formData.append("preset", jsonPreset);
    var xhr = new XMLHttpRequest();
    xhr.open('POST', serverBaseURL + '/api/presets', true);
    xhr.setRequestHeader("Accept", "application/json");

    xhr.onload = function () {
      // created
      if (xhr.status === 201) {
        toastOk("Preset saved! ;-)");
        $scope.onPresetCancel();
      } else if (xhr.status === 409) {
        console.log(xhr.response);
        toastError("Preset name " + $scope.preset.name + " already taken for category " + $scope.preset.categorySelected.name);
      } else {
        toastError("Ops! Something went wrong :-(");
        $scope.onPresetCancel();
      }
    };

    xhr.send(formData);
  };

  $scope.uploadFiles = function () {
    var formData = new FormData(); // $('input[type="file"]').each(function(index) {
    //
    //     let fileList = $(this)[0].files;
    //
    //     for(let i = 0; i < fileList.length; i++) {
    //         let file = fileList[i];
    //         formData.append(file.name, file);
    //     }
    // });
    // drumMachine.tracks.forEach(track => {
    //
    //     console.log(track);
    //     let buffer = track.buffer;
    //     let blob = new Blob(buffer);
    //     formData.append(track.name, blob, "campione.wav");
    //
    // });

    for (var id in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(id)) {
        var track = drumMachine.tracks[id];
        var blob = new Blob([track.sampleData.originalBuffer], {
          // type: track.sampleData.extension ? "audio/" + track.sampleData.extension : "octet-stream"
          type: "octet-stream"
        });
        formData.append("sample", blob, track.sampleData.fileName);
      }
    }

    var obj = {
      name: "track",
      bpm: 120,
      tracks: [{
        name: "kick"
      }, {
        name: "snare"
      }]
    };
    formData.append("preset", JSON.stringify(obj));
    var xhr = new XMLHttpRequest();
    xhr.open('POST', serverBaseURL + '/api/upload', true);
    xhr.setRequestHeader("Accept", "application/json");
    xhr.onload = handler;
    xhr.send(formData);

    function handler(e) {
      console.log(e);
    } // $http({
    //     url: "http://localhost:4500/upload",
    //     method: "POST",
    //     transformRequest: angular.identity,
    //     header: {
    //         "Content-Type": undefined,
    //     },
    //     data: formData
    // }).then(response => {
    //     console.log(response);
    // }, error => {
    //     console.log(error);
    // });

  };

  $scope.postComment = function () {
    var data = {
      username: $scope.username,
      message: $scope.commentToPost
    };
    $http({
      url: serverBaseURL + '/api/comments',
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      data: JSON.stringify(data)
    }).then(function (response) {
      console.log(response);
    }, function (response) {
      console.log(response);
    });
  };

  $scope.onPresetCancel = function () {
    $(".save-preset-container").remove();
  };

  $scope.onPresetSave = function () {
    $scope.savePreset();
  };
  /*
   * ---------------------------------------------------------------------------------------
   * private
   * ---------------------------------------------------------------------------------------
   */


  function removeTrack(track) {
    drumMachine.removeTrack(track.id);
  }

  function initDefaultTracks($scope, drumMachine) {
    enableLoadingSpinner();

    drumMachine._loadDefaultBuffers().then(function () {
      drumMachine._initDefaultTracks();

      $scope.tracks = drumMachine.tracks;
      $scope.$apply();
      disableLoadingSpinner();
    }, function (error) {
      console.log(error);
    });
  }

  function initDATgui(drumMachine) {
    var gui = new dat.GUI();
    var bpmController = gui.add(drumMachine, "bpm", 50.0, 220.0);
    bpmController.onChange(function (value) {
      drumMachine.bpm = Math.floor(drumMachine.bpm);
    });
  }

  function initSequencerControls(scope, drumMachine) {
    playBtn.on("mousedown touchstart", function (e) {
      e.preventDefault();
      e.stopPropagation();
      playBtn.css({
        backgroundColor: "#444"
      });
    });
    playBtn.on("mouseup touchend", function (e) {
      play(e);
    });
    stopBtn.on("mousedown touchstart", function (e) {
      e.preventDefault();
      e.stopPropagation();
      stopBtn.css({
        backgroundColor: "#444"
      });
    });
    stopBtn.on("mouseup touchend", function (e) {
      stop(e);
    });
    bpmSlider.slider({
      min: drumMachine.bpmMin,
      max: drumMachine.bpmMax,
      orientation: "horizontal",
      value: scope.bpm,
      slide: function slide(event, ui) {
        drumMachine.bpm = ui.value;
        scope.bpm = ui.value;
        scope.$apply();
      }
    }).draggable();

    scope.updateSlider = function () {
      if (drumMachine.isInRangeBPM(scope.bpm)) {
        bpmSlider.slider("value", scope.bpm);
        drumMachine.bpm = scope.bpm;
      }
    };
  }

  function play(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    } // playBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Play-50-green.png)"
    // });
    //
    // stopBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Stop-50-white.png)"
    // });


    stopBtn.removeClass("sequencer-stop-active");
    playBtn.removeClass("sequencer-play-inactive");
    stopBtn.addClass("sequencer-stop-inactive");
    playBtn.addClass("sequencer-play-active");
    playBtn.css({
      backgroundColor: "transparent"
    });
    stopBtn.css({
      backgroundColor: "transparent"
    });
    $scope.startSequencer();
  }

  function stop(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    } // stopBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Stop-50-red.png)"
    // });
    //
    // playBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Play-50-white.png)"
    // });


    playBtn.removeClass("sequencer-play-active");
    stopBtn.removeClass("sequencer-stop-inactive");
    playBtn.addClass("sequencer-play-inactive");
    stopBtn.addClass("sequencer-stop-active");
    playBtn.css({
      backgroundColor: "transparent"
    });
    stopBtn.css({
      backgroundColor: "transparent"
    });
    $scope.stopSequencer();
  }

  function loadPreset(data) {
    window.scrollTo(0, 0);
    enableLoadingSpinner();
    drumMachine.loadPreset(data).then(function (tracks) {
      tracks.forEach(function (t) {
        drumMachine.tracks[t.id] = t;
      });
      $scope.bpm = drumMachine.bpm;
      bpmSlider.slider("value", $scope.bpm);
      $scope.preset.name = data.name;
      $("#presetTitle").text($scope.preset.name);
      $scope.safeApply();
      disableLoadingSpinner();
    }, function (error) {
      console.log(error);
    });
  }

  function initExportMidiMenu() {
    var API = $("nav#menu").data("mmenu");
    var li = $('<li><a href="#exportMidi" >Export midi</a></li>');
    li.click($scope.exportMidi);
    $("#menu-list").find(".mm-listview").append(li);
    API.initPanels($("#menu-list"));
  }

  function initPresetsMenu(_x) {
    return _initPresetsMenu.apply(this, arguments);
  }

  function _initPresetsMenu() {
    _initPresetsMenu = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee(categories) {
      var response, presetsData, liParent, ulParent, API;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return $http({
                url: serverBaseURL + "/api/presets",
                method: "GET",
                headers: {
                  "Accept": "application/json"
                }
              });

            case 3:
              response = _context.sent;
              _context.next = 10;
              break;

            case 6:
              _context.prev = 6;
              _context.t0 = _context["catch"](0);
              console.error(_context.t0);
              return _context.abrupt("return");

            case 10:
              presetsData = response.data;

              if (!(presetsData.length === 0)) {
                _context.next = 13;
                break;
              }

              return _context.abrupt("return");

            case 13:
              $('li[id="presetsMenu"]').remove();
              liParent = $('<li id="presetsMenu"><a href="#">Presets</a></li>');
              ulParent = $("<ul></ul>");
              liParent.append(ulParent);
              categories.forEach(function (category) {
                var matches = presetsData.filter(function (p) {
                  return p.category === category.name;
                });
                if (!matches.length) return;
                var liCategory = $('<li><a href="#">' + category.name + '</a></li>');
                var ul = $("<ul></ul>");
                matches.forEach(function (preset) {
                  var li = $('<li><a href="#">' + preset.name + '</a></li>');
                  li.click(function () {
                    loadPreset(preset);
                  });
                  ul.append(li);
                });
                liCategory.append(ul);
                ulParent.append(liCategory);
              });
              API = $("nav#menu").data("mmenu");
              $("#menu-list").find(".mm-listview li:first").after(liParent);
              API.initPanels($("#menu-list"));

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 6]]);
    }));
    return _initPresetsMenu.apply(this, arguments);
  }

  function initSavePresetMenu() {
    var li = $('<li><a href="#">Save preset</a></li>');
    li.click(function () {
      var savePreset = angular.element(document.createElement('save-preset'));
      var domElem = $compile(savePreset)($scope);
      angular.element(document.body).append(domElem);
    });
    var API = $("nav#menu").data("mmenu");
    $("#menu-list").find(".mm-listview").append(li);
    API.initPanels($("#menu-list"));
  }

  function loadComments() {
    return _loadComments.apply(this, arguments);
  }

  function _loadComments() {
    _loadComments = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee2() {
      var response;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              enableCommentsLoadingSpinner();
              _context2.prev = 1;
              _context2.next = 4;
              return $http({
                url: serverBaseURL + '/api/comments',
                method: "GET",
                headers: {
                  "Accept": "application/json"
                }
              });

            case 4:
              response = _context2.sent;
              _context2.next = 11;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](1);
              console.error(_context2.t0);
              return _context2.abrupt("return");

            case 11:
              $scope.comments = response.data;
              $scope.safeApply();
              disableCommentsLoadingSpinner();

            case 14:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 7]]);
    }));
    return _loadComments.apply(this, arguments);
  }

  function enableLoadingSpinner() {
    setTimeout(function () {
      window.scrollTo(0, 0);
      loadingContainer.addClass("loading-active");
    }, 0);
  }

  function disableLoadingSpinner() {
    setTimeout(function () {
      window.scrollTo(0, 0);
      loadingContainer.removeClass("loading-active");
    }, 1500);
  }

  function enableCommentsLoadingSpinner() {
    setTimeout(function () {
      commentsLoadingOverlay.addClass("loading-active");
      commentsLoadingSpinner.addClass("loading-active");
    }, 0);
  }

  function disableCommentsLoadingSpinner() {
    setTimeout(function () {
      commentsLoadingOverlay.removeClass("loading-active");
      commentsLoadingSpinner.removeClass("loading-active");
    }, 100);
  }

  function toastError(text) {
    $.toast({
      text: text,
      showHideTransition: 'slide',
      // It can be plain, fade or slide
      bgColor: '#ff4a40',
      // Background color for toast
      textColor: '#fff',
      // text color
      allowToastClose: false,
      // Show the close button or not
      hideAfter: 3000,
      // `false` to make it sticky or time in miliseconds to hide after
      stack: 5,
      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once
      textAlign: 'left',
      // Alignment of text i.e. left, right, center
      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page

    });
  }

  function toastOk(text) {
    $.toast({
      text: text,
      showHideTransition: 'slide',
      // It can be plain, fade or slide
      bgColor: '#05a2fc',
      // Background color for toast
      textColor: '#fff',
      // text color
      allowToastClose: false,
      // Show the close button or not
      hideAfter: 3000,
      // `false` to make it sticky or time in miliseconds to hide after
      stack: 5,
      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once
      textAlign: 'left',
      // Alignment of text i.e. left, right, center
      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page

    });
  }
  /**
   * ---------------------------------------------------------------------------------------
   * init
   * ---------------------------------------------------------------------------------------
   */


  var socket = io.connect(serverBaseURL);
  initSequencerControls($scope, drumMachine);
  loadPreset(_presets.groovyRockPreset);
  window.scrollTo(0, 0);
  $(window).ready(function () {
    window.scrollTo(0, 0);
    initSavePresetMenu();
    initExportMidiMenu();
    $scope.populateCategories().then(function (categories) {
      initPresetsMenu(categories);
    });
    $interval(function () {
      $scope.populateCategories().then(function (categories) {
        console.log("$interval: populateCategories");
      });
    }, 20000);
    socket.on(socketEvents.newPreset, function (data) {
      console.log(socketEvents.newPreset, data);
      initPresetsMenu($scope.preset.categories);
    });
    socket.on(socketEvents.newComment, function (comment) {
      // toastOk("Comment posted!");
      $scope.comments.splice(0, 0, comment);
      $scope.commentToPost = "";
      $scope.commentForm.$setPristine();
      $scope.safeApply();
    });
  });
}

},{"../../audio/DrumMachine":3,"../../audio/audio-loader":6,"../../audio/presets":7}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testController = testController;

/*
 * ---------------------------------------------------------------------------------------
 * testController.js
 * ---------------------------------------------------------------------------------------
 */
function testController($scope) {
  $scope.title = "Test Controller";
  console.log("Test Controller");
}

},{}],10:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * commentDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commentDirective = commentDirective;

function commentDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    templateUrl: "app/directives/templates/commentDirective.html",
    link: function link(scope, elem, attrs) {}
  };
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSamples = loadSamples;

var _audioLoader = require("../audio/audio-loader");

/**
 * ---------------------------------------------------------------------------------------
 * loadSoundsDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

function loadSamples($http, supportedAudioFormats) {
  var serverBaseURL = "http://localhost:4500";
  return {
    restrict: 'AE',
    replace: 'false',
    // scope: {
    //     samplesData: "="
    // },
    templateUrl: "app/directives/templates/loadSamples.html",
    link: function link(scope, elem, attrs) {
      /*
       * ---------------------------------------------------------------------------------------
       * styles & widgets
       * ---------------------------------------------------------------------------------------
       */
      function initUI() {
        $(".samples-accordion").accordion({
          animate: 200,
          collapsible: true,
          active: false,
          heightStyle: "content"
        });
        elem.find('button[name="playSampleButton"]').button({
          icon: "ui-icon-circle-triangle-e",
          showLabel: false
        });
        elem.find('button[name="loadSampleButton"]').button({
          icon: "ui-icon-check",
          showLabel: false
        });
        elem.find('button[id="samplesCancelBtn"]').button();
        elem.css("display", "block");
        scope.disableLoadingSpinner();
      }
      /*
       * ---------------------------------------------------------------------------------------
       * event listeners
       * ---------------------------------------------------------------------------------------
       */


      function addEvents() {}
      /*
       * ---------------------------------------------------------------------------------------
       * functions
       * ---------------------------------------------------------------------------------------
       */


      scope.close = function () {
        $("#angularView").css("display", "block");
        elem.remove();
      };

      scope.playSampleFromServer = function (sample) {
        if (!sample) return;

        if (scope.samplesBuffers.hasOwnProperty(sample.path)) {
          var buffer = scope.samplesBuffers[sample.path];
          scope.playSoundFromBuffer(buffer);
        } else {
          scope.audioLoader(scope.audioContext, sample.path).then(function (buffer) {
            scope.samplesBuffers[sample.path] = buffer;
            scope.playSoundFromBuffer(buffer);
          });
        }
      };

      scope.loadSampleOnTrack = function (sample) {
        if (!sample) return;
        (0, _audioLoader.getArrayBuffer)(scope.audioContext, sample.path).then(function (arrayBuffer) {
          scope.track.setSampleData(sample.name, arrayBuffer);
          scope.close();
        });
      };
      /*
       * ---------------------------------------------------------------------------------------
       * init
       * ---------------------------------------------------------------------------------------
       */


      function init() {
        // hide content behind
        $("#angularView").css("display", "none");
        var intervalID = setInterval(function () {
          var result = $(".samples-accordion");

          if (result.length > 0) {
            clearInterval(intervalID);
            initUI();
            addEvents();
          }
        }, 200);
      }

      init();
    }
  };
}

},{"../audio/audio-loader":6}],12:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * savePresetDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.savePresetDirective = savePresetDirective;

function savePresetDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    templateUrl: "app/directives/templates/savePreset.html",
    link: function link(scope, elem, attrs) {
      scope.tagHandler = function (tag) {
        return null;
      };

      scope.invalidPresetNameMessage = "Choose a preset name (4-24 characters)";
      scope.invalidCategoryMessage = "Choose a category";

      function initUI() {
        $("#presetCancelBtn").button();
        $("#presetSaveBtn").button();
      }
      /**
       * ---------------------------------------------------------------------------------------
       * init
       * ---------------------------------------------------------------------------------------
       */


      initUI();
    }
  };
}

},{}],13:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * tickSliderDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tickSliderDirective = tickSliderDirective;

function tickSliderDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    scope: {
      tick: "=",
      ticksElements: "=",
      resizeTick: "="
    },
    link: function link(scope, elem, attrs) {
      // console.log(scope.tick);
      scope.ticksElements.push(elem);
      elem.slider({
        min: 0,
        max: 100,
        orientation: "vertical",
        value: scope.tick.active ? scope.tick.volume * 100 : 0,
        slide: function slide(event, ui) {
          if (ui.value === 0) {
            scope.tick.active = false;
          } else {
            scope.tick.active = true;
          }

          scope.tick.volume = ui.value * 0.01; // console.log(scope.tick.volume);
        }
      }).draggable(); // scope.resizeTick(elem);
    }
  };
}

},{}],14:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * trackDirective
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackDirective = trackDirective;

var _utils = require("../utils/utils");

function trackDirective($http, $compile, supportedAudioFormats) {
  return {
    restrict: 'AE',
    replace: 'false',
    scope: {
      track: "=",
      ticksElements: "=",
      samplesData: "=",
      samplesBuffers: "=",
      removeTrack: "=",
      audioContext: "=",
      audioLoader: "=",
      playSoundFromBuffer: "=",
      enableLoadingSpinner: "=",
      disableLoadingSpinner: "="
    },
    templateUrl: "app/directives/templates/trackDirective.html",
    link: function link(scope, elem, attrs) {
      var serverBaseURL = "http://localhost:4500";
      scope.resizeTick = resizeTick;
      scope.handleFiles = handleFiles;
      scope.playSound = playSound;
      scope.onSoloTrack = onSoloTrack;
      scope.onMuteTrack = onMuteTrack;
      scope.loadSamplesFromServer = loadSamplesFromServer;
      /*
       * ---------------------------------------------------------------------------------------
       * styles & widgets
       * ---------------------------------------------------------------------------------------
       */

      elem.find('button[name="removeTrackButton"]').button({
        icon: "ui-icon-close",
        showLabel: false
      });
      elem.find('button[name="playSoundButton"]').button({
        icon: "ui-icon-circle-triangle-e",
        showLabel: false
      });
      elem.find('button[name="loadSoundFromServerBtn"]').button();
      elem.find('div[id="trackVolumeSlider"]').slider({
        min: 0,
        max: 100,
        orientation: "horizontal",
        value: scope.track.gainNode.gain.value * 100,
        slide: function slide(event, ui) {
          scope.track.gainNode.gain.value = ui.value * 0.01;
        }
      }).draggable();

      if (scope.track.pannerNodeSupported) {
        elem.find('div[id="trackPanSlider"]').slider({
          min: -100,
          max: 100,
          orientation: "horizontal",
          value: scope.track.pannerNode.pan.value * 100,
          slide: function slide(event, ui) {
            scope.track.pannerNode.pan.value = ui.value * 0.01;
          }
        }).draggable();
      } else {
        elem.find('div[id="trackPanSlider"]').remove();
        elem.find(".pan-label").remove(); // push down volume slider

        elem.find('div[id="trackVolumeSlider"]').css({// marginTop: 0,
          // position: "relative",
          // bottom: 0
        });
      }

      elem.find('button[name="soloTrackButton"]').button();
      elem.find('button[name="muteTrackButton"]').button();
      elem.find('button[name="loadSoundFromServerBtn"]').button({
        showLabel: false,
        icon: "ui-icon-volume-on"
      });
      /*
       * ---------------------------------------------------------------------------------------
       * event listeners
       * ---------------------------------------------------------------------------------------
       */

      scope.$on("$destroy", function () {
        elem.unbind("dragover", onDragOver);
        elem.unbind("drop", onDrop);
        elem.unbind("dragleave", onDragLeave);
      });
      elem.on("dragover", onDragOver);
      elem.on("drop", onDrop);
      elem.on("dragleave", onDragLeave);
      /*
       * ---------------------------------------------------------------------------------------
       * private functions
       * ---------------------------------------------------------------------------------------
       */

      function resizeTick(tickElem) {
        var ticksContainerWidth = elem.find(".ticks-container").width();
        console.log(ticksContainerWidth);
        var margin = 8;
        var tickWidth = Math.floor((ticksContainerWidth - 15 * margin) / 16.0); // tickElem.css({
        //     width: 32,
        //     marginRight: "8px !important"
        // });
        // tickElem.parent().css({
        //     width: tickWidth,
        //     marginRight: margin
        // });
        // tickElem.find(".ui-slider-handle").css({
        //
        // });
      }

      function handleFiles(files) {
        if (!files || files.length < 1) return;
        var file = files[0];
        var fileExtension = (0, _utils.getFileExtension)(file.name); // chech if it is an audio file with a supported extension

        if (!supportedAudioFormats.has(fileExtension)) {
          console.log("File format not supported by Web Audio API: ", fileExtension);
          return;
        }

        var reader = new FileReader();

        reader.onload = function (ev) {
          var arrayBuffer = ev.target.result;
          scope.track.setSampleData(file.name, arrayBuffer);
        };

        reader.readAsArrayBuffer(file);
      }

      function onDragOver(e) {
        if (!elem.hasClass("track-dragfile")) {
          elem.addClass("track-dragfile");
        }

        e.stopPropagation();
        e.preventDefault();
      }

      function onDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        handleFiles(e.originalEvent.dataTransfer.files);
        onDragLeave();
      }

      function onDragLeave(e) {
        if (elem.hasClass("track-dragfile")) {
          elem.removeClass("track-dragfile");
        }

        if (e) {
          e.stopPropagation();
          e.preventDefault();
        }
      }

      function playSound() {
        scope.track.playLoadedSample();
      }

      function onSoloTrack() {
        scope.track.drumMachine.soloTrack(scope.track.id);
      }

      function onMuteTrack() {
        scope.track.drumMachine.muteTrack(scope.track.id);
      }

      function loadSamplesFromServer() {
        scope.enableLoadingSpinner();
        $http({
          url: serverBaseURL + "/api/samples",
          method: "GET",
          headers: {
            "Accept": "application/json"
          }
        }).then(function (response) {
          scope.samplesData = response.data;
          var loadSamplesElem = $('<load-samples></load-samples>');
          var el = $compile(loadSamplesElem)(scope);
          $("body").append(el);
        });
      }
    }
  };
}

},{"../utils/utils":16}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initRoutes = initRoutes;

/*
 * ---------------------------------------------------------------------------------------
 * routes.js
 * ---------------------------------------------------------------------------------------
 */
function initRoutes($routeProvider) {
  $routeProvider.when('/', {
    controller: "drumMachineController",
    templateUrl: "app/components/drum-machine/drumMachineView.html"
  });
  $routeProvider.when('/test', {
    controller: "testController",
    templateUrl: "app/components/test/testView.html"
  });
  $routeProvider.otherwise({
    redirectTo: '/'
  });
}

},{}],16:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * utils.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";
/*
 * checkIfiOSdevice
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkIfiOSdevice = checkIfiOSdevice;
exports.guid = guid;
exports.getExtensionFromFileName = getExtensionFromFileName;
exports.getFileNameFromPath = getFileNameFromPath;
exports.getArrayAudioBufferFromUrl = getArrayAudioBufferFromUrl;
exports.getFileExtension = getFileExtension;

function checkIfiOSdevice() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
/*
 * generate uuid
 */


function guid() {
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return uuid;
}

function getExtensionFromFileName(fileName) {
  var re = /(?:\.([^.]+))?$/;
  var ext = re.exec(fileName)[1];
  return ext;
}

function getFileNameFromPath(path) {
  return path.replace(/^.*[\\\/]/, '');
}

function getArrayAudioBufferFromUrl(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      resolve(xhr.response);
    };

    xhr.send();
  });
}

function getFileExtension(fileName) {
  return fileName.substr(fileName.lastIndexOf('.') + 1);
}

},{}]},{},[2]);

//# sourceMappingURL=app.bundle.min.js.map
