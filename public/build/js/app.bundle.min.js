(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * app.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

var _routes = require("./routes");

var _drumMachineController = require("./components/drum-machine/drumMachineController");

var _testController = require("./components/test/testController");

var _trackDirective = require("./directives/trackDirective");

var _tickSliderDirective = require("./directives/tickSliderDirective");

var _commentDirective = require("./directives/commentDirective");

var _savePresetDirective = require("./directives/savePresetDirective");

var _loadSamples = require("./directives/loadSamples");

(function () {
  var app = angular.module("myApp", ["ngRoute", "ngFileSaver", "ngSanitize", "ui.select"]);
  console.log(app); // configure angular routes

  app.config(["$routeProvider", _routes.initRoutes]); // bind controllers

  app.controller("drumMachineController", ["$scope", "$compile", "$http", "$interval", "serverBaseURL", "FileSaver", "Blob", "socketEvents", _drumMachineController.drumMachineController]);
  app.controller("testController", ['$scope', _testController.testController]); // register directives

  app.directive("tickSlider", _tickSliderDirective.tickSliderDirective);
  app.directive("theTrack", ["$http", "$compile", "supportedAudioFormats", _trackDirective.trackDirective]);
  app.directive("comment", _commentDirective.commentDirective);
  app.directive("savePreset", _savePresetDirective.savePresetDirective);
  app.directive("loadSamples", ["$http", "supportedAudioFormats", _loadSamples.loadSamples]);
  var supportedAudioFormats = new Set();
  supportedAudioFormats.add("wav");
  supportedAudioFormats.add("audio/wav");
  supportedAudioFormats.add("audio/x-wav");
  supportedAudioFormats.add("mp3");
  supportedAudioFormats.add("audio/mp3");
  supportedAudioFormats.add("audio/x-mp3");
  supportedAudioFormats.add("ogg");
  supportedAudioFormats.add("audio/ogg");
  supportedAudioFormats.add("audio/x-ogg");
  var socketEvents = {
    newPreset: "NEW_PRESET",
    newComment: "NEW_COMMENT"
  }; // constants

  app.constant("serverBaseURL", "http://192.168.1.75:4500");
  app.constant("supportedAudioFormats", supportedAudioFormats);
  app.constant("socketEvents", socketEvents);
})();

},{"./components/drum-machine/drumMachineController":7,"./components/test/testController":8,"./directives/commentDirective":9,"./directives/loadSamples":10,"./directives/savePresetDirective":11,"./directives/tickSliderDirective":12,"./directives/trackDirective":13,"./routes":14}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DrumMachine = void 0;

var _audioLoader = require("./audio-loader");

var _utils = require("../utils/utils");

var _Track = require("./Track");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DrumMachine =
/*#__PURE__*/
function () {
  function DrumMachine() {
    _classCallCheck(this, DrumMachine);

    this.tag = "[DrumMachine.js]";
    this.numberOfBeats = 16;
    var AudioContext = window.AudioContext || window.webkitAudioContext;
    this.audioContext = new AudioContext();
    this.pannerNodeSupported = false;
    this.bpm = 120;
    this.bpmMin = 30;
    this.bpmMax = 240;
    this.timeSignature = {
      num: 4,
      den: 4
    };
    this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note

    this.isPlaying = false;
    this.isStopped = true;
    this.buffers = {};
    this.tracks = {}; // this.defaultBuffersLoaded = false;
    // this.defaultTracksLoaded = false;

    this._tracksInSolo = new Set();
    this._tracksInMute = new Set();
    this.currentTickIndex = 0;
    this.callBacksInLoop = [];
    this.soundURLs = {
      kick: "app/assets/audio/kick.wav",
      snare: "app/assets/audio/snare.wav",
      hat: "app/assets/audio/hat.wav",
      ride: "app/assets/audio/ride.wav"
    };

    if ((0, _utils.checkIfiOSdevice)()) {
      this._enableAudioContextForiOS();
    } else {
      this.audioContextEnabled = true;
    }

    if (typeof this.audioContext.createStereoPanner === "function") {
      this.pannerNodeSupported = true;
      console.log("Stereo panner supported");
    } else {
      console.log("Stereo panner not supported");
    }
  }
  /*
   * get bpm
   */


  _createClass(DrumMachine, [{
    key: "_enableAudioContextForiOS",
    value: function _enableAudioContextForiOS() {
      var _this = this;

      $(document).ready(function () {
        var btn = $("<button/>", {
          visibility: "hidden"
        });
        btn.on("touchstart", function () {
          var buffer = _this.audioContext.createBuffer(1, 1, 22050);

          var source = _this.audioContext.createBufferSource();

          source.buffer = buffer;
          source.start();
          _this.audioContextEnabled = true;
          console.log("AudioContext enabled for iOS");
        });
        btn.trigger("touchstart");
      });
    }
    /*
    _loadDefaultBuffers() {
          let ctx = this.audioContext;
        let urls = this.soundURLs;
          return new Promise((resolve, reject) => {
            Promise.all([
                audioLoader(ctx, urls.kick),
                audioLoader(ctx, urls.snare),
                audioLoader(ctx, urls.hat),
                audioLoader(ctx, urls.ride)
            ]).then(values => {
                this.buffers["kick"] = values[0];
                this.buffers["snare"] = values[1];
                this.buffers["hat"] = values[2];
                this.buffers["ride"] = values[3];
                this.defaultBuffersLoaded = true;
                console.log(this.buffers);
                  this.defaultBuffersLoaded = true;
                console.log("Default buffers loaded");
                // this._initDefaultTracks();
                  resolve("Default buffers loaded");
              }, error => {
                reject(error);
            });
        });
    }
        _initDefaultTracks() {
          if (!this.defaultBuffersLoaded) {
            return;
        }
          this.tracks = {};
          let kickTrack = new Track(this, "kick", this.buffers["kick"]);
        kickTrack.setTicksFromArray([0,4,8,12]);
        let snareTrack = new Track(this, "snare", this.buffers["snare"], 1, 0.1);
        snareTrack.setTicksFromArray([4,12]);
        let hatTrack = new Track(this, "hat", this.buffers["hat"], 0.85, -1);
        // hatTrack.setTicksFromArray([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);
            hatTrack.setTicksFromArray([
            {
                active: true,
                index: 0,
                volume: 0.5
            },
            {
                active: true,
                index: 1,
                volume: 0.5
            },
            {
                active: true,
                index: 2,
                volume: 1.2
            },
            {
                active: true,
                index: 3,
                volume: 0.4
            },
            {
                active: true,
                index: 4,
                volume: 0.9
            },
            {
                active: true,
                index: 5,
                volume: 0.5
            },
            {
                active: true,
                index: 6,
                volume: 1
            },
            {
                active: true,
                index: 7,
                volume: 0.4
            },
            {
                active: true,
                index: 8,
                volume: 0.9
            },
            {
                active: true,
                index: 9,
                volume: 0.5
            },
            {
                active: true,
                index: 10,
                volume: 1
            },
            {
                active: true,
                index: 11,
                volume: 0.4
            },
            {
                active: true,
                index: 12,
                volume: 0.9
            },
            {
                active: true,
                index: 13,
                volume: 0.5
            },
            {
                active: true,
                index: 14,
                volume: 1
            },
            {
                active: true,
                index: 15,
                volume: 0.4
            }
        ]);
          this.tracks[kickTrack.id] = kickTrack;
        this.tracks[snareTrack.id] = snareTrack;
        this.tracks[hatTrack.id] = hatTrack;
          this.defaultTracksLoaded = true;
        console.log("Default tracks loaded" , this.tracks);
          // this._start();
    }
    */

  }, {
    key: "_onBpmChanged",
    value: function _onBpmChanged() {
      this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note
    }
  }, {
    key: "_start",
    value: function _start() {
      if (!this.audioContextEnabled) {
        console.log("Cannot play: AudioContext is not enabled.");
        return;
      }

      if (this.isPlaying) {
        console.log("Cannot play: it is already playing.");
        return;
      }

      this.isStopped = false;
      var self = this;
      var ctx = this.audioContext;
      var startTime = ctx.currentTime;
      var nextTickTime = startTime + self.tickTime;
      var index = 0;
      var timeOutID;
      var firstLoopEnded = false;

      function scheduler() {
        if (self.isStopped) {
          clearTimeout(timeOutID);
          self.isPlaying = false;
          return;
        }

        if (nextTickTime <= ctx.currentTime + self.tickTime) {
          self.isPlaying = true;
          self.isStopped = false;
          $.each(self.tracks, function (id, track) {
            if (track.mute) {
              return;
            }

            if (!track.sampleData.decodedAudioBuffer) {
              return;
            }

            var trackTick = track.ticks[index];

            if (!trackTick.active) {
              return;
            }

            var tickSound = ctx.createBufferSource();
            tickSound.buffer = track.sampleData.decodedAudioBuffer;
            var tickGainNode = ctx.createGain();
            tickSound.connect(tickGainNode);
            tickGainNode.gain.value = trackTick.volume;
            tickGainNode.connect(track.gainNode);
            tickSound.start(nextTickTime);
          });
          self.currentTickIndex = index;
          var previousIndex = index === 0 ? self.numberOfBeats - 1 : index - 1;
          var previousPrevious = previousIndex === 0 ? self.numberOfBeats - 1 : previousIndex - 1; // to syncronize web audio api schedule with ui beat indicators

          if (firstLoopEnded) {
            self.callBacksInLoop.forEach(function (fn) {
              fn(previousPrevious, previousIndex);
            });
          }

          nextTickTime += self.tickTime;
          index = ++index === self.numberOfBeats ? 0 : index;
        }

        firstLoopEnded = true;
        timeOutID = window.setTimeout(scheduler, 0);
      }

      scheduler();
    }
  }, {
    key: "_stop",
    value: function _stop() {
      this.isStopped = true;
    }
  }, {
    key: "_playSound",
    value: function _playSound(bufferName, time) {
      var ctx = this.audioContext;
      var sound = ctx.createBufferSource();
      sound.buffer = this.buffers[bufferName];
      sound.connect(ctx.destination);
      sound.start(time);
    }
  }, {
    key: "playSoundFromBuffer",
    value: function playSoundFromBuffer(buffer, time) {
      if (!buffer) return;
      var ctx = this.audioContext;
      var sound = ctx.createBufferSource();
      sound.buffer = buffer;
      sound.connect(ctx.destination);

      if (time) {
        sound.start(time);
      } else {
        sound.start();
      }
    }
  }, {
    key: "removeTrack",
    value: function removeTrack(trackID) {
      var track = this.tracks[trackID];

      this._tracksInSolo["delete"](track);

      this._tracksInMute["delete"](track);

      delete this.tracks[trackID];
    }
  }, {
    key: "soloTrack",
    value: function soloTrack(trackID) {
      if (!this.tracks.hasOwnProperty(trackID)) return;
      var focusTrack = this.tracks[trackID];
      var tracksInSolo = this._tracksInSolo;
      var tracksInMute = this._tracksInMute; // case 1: track is not in solo and not in mute

      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {
        tracksInSolo.add(focusTrack);
        focusTrack.solo = true;
        focusTrack.mute = false;
        $.each(this.tracks, function (id, track) {
          if (id === trackID) {
            return;
          }

          if (!tracksInSolo.has(track)) {
            tracksInMute.add(track);
            track.mute = true;
            track.solo = false;
          }
        });
      } // case 2: track is in solo
      else if (tracksInSolo.has(focusTrack)) {
          tracksInSolo["delete"](focusTrack);
          focusTrack.solo = false;

          if (tracksInSolo.size > 0) {
            tracksInMute.add(focusTrack);
            focusTrack.mute = true;
          } else {
            tracksInMute.clear();
            tracksInSolo.clear();
            $.each(this.tracks, function (id, track) {
              track.mute = false;
              track.solo = false;
            });
          }
        } // case 3: track is in mute
        else {
            tracksInSolo.add(focusTrack);
            focusTrack.solo = true;
            focusTrack.mute = false;

            if (tracksInSolo.size === 1) {
              $.each(this.tracks, function (id, track) {
                if (id !== trackID) {
                  tracksInMute.add(track);
                  track.mute = true;
                }
              });
            }
          }
    }
  }, {
    key: "muteTrack",
    value: function muteTrack(trackID) {
      if (!this.tracks.hasOwnProperty(trackID)) return;
      var focusTrack = this.tracks[trackID];
      var tracksInSolo = this._tracksInSolo;
      var tracksInMute = this._tracksInMute; // case 1: track not in solo or mute

      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {
        tracksInMute.add(focusTrack);
        focusTrack.mute = true;
        focusTrack.solo = false;
      } // case 2: track is in solo
      else if (tracksInSolo.has(focusTrack)) {
          tracksInSolo["delete"](focusTrack);
          tracksInMute.add(focusTrack);
          focusTrack.solo = false;
          focusTrack.mute = true;

          if (tracksInSolo.size === 0) {
            $.each(this.tracks, function (id, track) {
              if (id !== trackID) {
                tracksInMute["delete"](track);
                track.mute = false;
              }
            });
          }
        } // case 3: track is in mute
        else if (tracksInMute.has(focusTrack)) {
            if (tracksInSolo.size > 0) {
              tracksInMute["delete"](focusTrack);
              tracksInSolo.add(focusTrack);
              focusTrack.mute = false;
              focusTrack.solo = true;
            } else {
              tracksInMute["delete"](focusTrack);
              focusTrack.mute = false;
            }
          }
    }
  }, {
    key: "addCallBackInLoop",
    value: function addCallBackInLoop(fn) {
      if (!_typeof(fn) === "function") return;
      this.callBacksInLoop.push(fn);
    }
  }, {
    key: "isInRangeBPM",
    value: function isInRangeBPM(value) {
      if (value >= this.bpmMin && value <= this.bpmMax) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "_createEmptyTicksArray",
    value: function _createEmptyTicksArray() {
      var ticks = [];

      for (var i = 0; i < this.numberOfBeats; i++) {
        ticks.push({
          index: i,
          volume: 0,
          active: false
        });
      }

      return ticks;
    }
  }, {
    key: "_clearTracks",
    value: function _clearTracks() {
      this._tracksInSolo.clear();

      this._tracksInMute.clear();

      for (var key in this.tracks) {
        if (this.tracks.hasOwnProperty(key)) {
          delete this.tracks[key];
        }
      }
    }
  }, {
    key: "addEmptyTrack",
    value: function addEmptyTrack() {
      var name = "track_" + (Object.keys(this.tracks).length + 1);
      var track = new _Track.Track(this, name);
      track.setTicksFromArray(this._createEmptyTicksArray());
      this.tracks[track.id] = track;
    }
  }, {
    key: "createTrack",
    value: function createTrack(name, soundPath, volume, pan, ticks) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        var track = new _Track.Track(_this2, name, soundPath);

        if (ticks) {
          track.setTicksFromArray(ticks);
        } else {
          track.setTicksFromArray(_this2._createEmptyTicksArray());
        }

        if (volume) {
          track.gainNode.gain.value = volume;
        }

        if (pan) {
          if (track.pannerNode) {
            track.pannerNode.pan.value = pan;
          }
        }

        resolve(track);
      });
    }
  }, {
    key: "loadPreset",
    value: function loadPreset(data) {
      var _this3 = this;

      try {
        this.bpm = data.bpm;

        this._clearTracks();

        var promises = [];
        data.tracks.forEach(function (track) {
          promises.push(_this3.createTrack(track.name, track.soundPath, track.volume, track.pan, track.ticks));
        });
        return Promise.all(promises);
      } catch (e) {
        return new Promise(function (resolve, reject) {
          reject(e);
        });
      }
    }
  }, {
    key: "buildJsonPreset",
    value: function buildJsonPreset(name, category) {
      var _this4 = this;

      var data = {
        name: name,
        category: category,
        bpm: this.bpm,
        timeSignature: this.timeSignature
      };
      var tracks = [];

      for (var id in this.tracks) {
        if (this.tracks.hasOwnProperty(id)) {
          (function () {
            var track = _this4.tracks[id];
            var trackData = {
              name: track.name,
              soundPath: category + "/" + track.sampleData.fileName,
              volume: track.gainNode.gain.value,
              pan: _this4.pannerNodeSupported ? track.pannerNode.pan.value : 0
            };
            var ticksData = [];
            track.ticks.forEach(function (tick) {
              ticksData.push({
                active: tick.active,
                index: tick.index,
                volume: tick.volume
              });
            });
            trackData.ticks = ticksData;
            tracks.push(trackData);
          })();
        }
      }

      data.tracks = tracks;
      return JSON.stringify(data);
    }
  }, {
    key: "bpm",
    get: function get() {
      return this._bpm;
    }
    /*
     * set bpm
     */
    ,
    set: function set(val) {
      if (val !== this._bpm) {
        this._bpm = val;

        this._onBpmChanged();
      }
    }
  }]);

  return DrumMachine;
}();

exports.DrumMachine = DrumMachine;

},{"../utils/utils":15,"./Track":4,"./audio-loader":5}],3:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * Tick.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Tick = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tick = function Tick() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

  _classCallCheck(this, Tick);

  this.index = index;
  this.active = active;
  this.volume = volume;
} // get volume() {
//     return this._volume;
// }
//
// set volume(val) {
//     this._volume = val > 1 ? 1.0 : val;
// }
;

exports.Tick = Tick;

},{}],4:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * Track.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Track = void 0;

var _Tick = require("./Tick");

var _utils = require("../utils/utils");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Track =
/*#__PURE__*/
function () {
  function Track(drumMachine) {
    var _this = this;

    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "track_default";
    var soundPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
    var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;
    var pan = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var mute = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

    _classCallCheck(this, Track);

    this.id = (0, _utils.guid)();
    this.drumMachine = drumMachine;
    this.audioContext = drumMachine.audioContext;
    this.name = name;
    this.sampleData = {
      fileName: "",
      extension: "",
      originalBuffer: undefined,
      decodedAudioBuffer: undefined
    };
    this.solo = false;
    this.mute = mute;
    this.ticks = [];
    this.pannerNodeSupported = false;
    this.gainNode = this.audioContext.createGain();
    this.gainNode.gain.value = volume;

    if (drumMachine.pannerNodeSupported) {
      this.pannerNode = this.audioContext.createStereoPanner();
      this.pannerNode.pan.value = pan;
      this.gainNode.connect(this.pannerNode);
      this.pannerNode.connect(this.audioContext.destination);
      this.pannerNodeSupported = true;
    } else {
      this.gainNode.connect(this.audioContext.destination);
    }

    if (soundPath) {
      (0, _utils.getArrayAudioBufferFromUrl)(this.audioContext, soundPath).then(function (buffer) {
        var fileName = (0, _utils.getFileNameFromPath)(soundPath);

        _this.setSampleData(fileName, buffer);
      });
    }

    this._initTicks();
  } // setGain(val) {
  //     this.gainNode.gain.value = val > 1 ? 1.0 : val;
  // }
  // setPan(val) {
  //     if (val < -1) {
  //         this.pannerNode.pan.value = -1;
  //     }
  //     else if (val > 1) {
  //         this.pannerNode.pan.value = 1;
  //     }
  //     else {
  //         this.pannerNode.pan.value = val;
  //     }
  // }

  /*
   *
   */


  _createClass(Track, [{
    key: "_initTicks",
    value: function _initTicks() {
      this.ticks = [];

      for (var i = 0; i < this.drumMachine.numberOfBeats; ++i) {
        this.ticks.push(new _Tick.Tick(i));
      }
    }
  }, {
    key: "setTick",
    value: function setTick(index) {
      var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;

      if (index < 0 || index > this.drumMachine.numberOfBeats - 1) {
        return;
      }

      this.ticks[index].volume = volume;
      this.ticks[index].active = active;
    }
  }, {
    key: "setTicksFromArray",
    value: function setTicksFromArray(data) {
      var _this2 = this;

      data.forEach(function (e) {
        if (_typeof(e) === "object") {
          if (e.index === "undefined" || e.index < 0 || e.index > _this2.drumMachine.numberOfBeats - 1) {
            return;
          }

          _this2.ticks[e.index].volume = e.volume !== "undefined" ? e.volume : 0;
          _this2.ticks[e.index].active = e.active !== "undefined" ? e.active : false;
        } else {
          _this2.ticks[e].active = true;
        }
      });
    }
  }, {
    key: "setBuffer",
    value: function setBuffer(arrayBuffer, fileName) {
      var _this3 = this;

      this.originalBuffer = arrayBuffer;
      this.drumMachine.audioContext.decodeAudioData(arrayBuffer, function (decodedAudioBuffer) {
        _this3.buffer = decodedAudioBuffer;
        console.log("Track " + _this3.name + ": audio buffer changed ( " + fileName + " )");
      });
    }
  }, {
    key: "playLoadedSample",
    value: function playLoadedSample() {
      if (!this.audioContext || !this.sampleData.decodedAudioBuffer) return;
      var sound = this.audioContext.createBufferSource();
      sound.buffer = this.sampleData.decodedAudioBuffer;
      sound.connect(this.audioContext.destination);
      sound.start();
    }
  }, {
    key: "setSampleData",
    value: function setSampleData(fileName, arrayAudioBuffer) {
      var _this4 = this;

      if (!fileName || !arrayAudioBuffer) {
        console.log("Missing fileName and/or arrayAudioBuffer parameters");
        return;
      }

      this.drumMachine.audioContext.decodeAudioData(arrayAudioBuffer, function (decodedBuffer) {
        _this4.sampleData.fileName = fileName;
        _this4.sampleData.extension = (0, _utils.getExtensionFromFileName)(fileName);
        _this4.sampleData.originalBuffer = arrayAudioBuffer;
        _this4.sampleData.decodedAudioBuffer = decodedBuffer;
      });
    }
  }]);

  return Track;
}();

exports.Track = Track;

},{"../utils/utils":15,"./Tick":3}],5:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * audio-loader.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.audioLoader = audioLoader;
exports.getArrayBuffer = getArrayBuffer;

function audioLoader(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      try {
        audioCtx.decodeAudioData(xhr.response, function (decodedBuffer) {
          resolve(decodedBuffer);
        });
      } catch (e) {
        reject(e);
      }
    };

    xhr.send();
  });
}

function getArrayBuffer(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      resolve(xhr.response);
    };

    xhr.send();
  });
}

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.psyTrancePreset = exports.groovyRockPreset = void 0;

/**
 * ---------------------------------------------------------------------------------------
 * presets.js
 * ---------------------------------------------------------------------------------------
 */
var groovyRockPreset = {
  name: "Straight rock",
  bpm: 120,
  category: "rock",
  timeSignature: {
    num: 4,
    den: 4
  },
  tracks: [{
    name: "kick",
    soundPath: "app/assets/samples/rock/rock-kick.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 0,
      volume: 1
    }, {
      active: true,
      index: 8,
      volume: 1
    }, {
      active: true,
      index: 10,
      volume: 1
    }]
  }, {
    name: "snare",
    soundPath: "app/assets/samples/rock/rock-snare.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "hh open",
    soundPath: "app/assets/samples/rock/rock-hh-open.wav",
    volume: 0.4,
    pan: 0.4,
    ticks: [{
      active: true,
      index: 4,
      volume: 0.8
    }, {
      active: true,
      index: 8,
      volume: 0.8
    }, {
      active: true,
      index: 12,
      volume: 0.8
    }]
  }, {
    name: "crash",
    soundPath: "app/assets/samples/rock/rock-crash.wav",
    volume: 0.5,
    pan: -0.5,
    ticks: [{
      active: true,
      index: 0,
      volume: 0.8
    }]
  }]
};
exports.groovyRockPreset = groovyRockPreset;
var psyTrancePreset = {
  name: "psy-trance",
  category: "trance",
  bpm: 145,
  timeSignature: {
    num: 4,
    den: 4
  },
  tracks: [{
    name: "kick",
    soundPath: "app/assets/samples/trance/trance-kick.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 0,
      volume: 1
    }, {
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 8,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "clap",
    soundPath: "app/assets/samples/trance/trance-clap.wav",
    volume: 1,
    pan: 0,
    ticks: [{
      active: true,
      index: 4,
      volume: 1
    }, {
      active: true,
      index: 12,
      volume: 1
    }]
  }, {
    name: "hh open",
    soundPath: "app/assets/samples/trance/trance-hh-open.wav",
    volume: 0.8,
    pan: 0.2,
    ticks: [{
      active: true,
      index: 2,
      volume: 0.8
    }, {
      active: true,
      index: 6,
      volume: 0.8
    }, {
      active: true,
      index: 10,
      volume: 0.8
    }, {
      active: true,
      index: 14,
      volume: 0.8
    }]
  }, {
    name: "bass",
    soundPath: "app/assets/samples/trance/trance-bass-A1.wav",
    volume: 0.8,
    pan: 0,
    ticks: [{
      active: true,
      index: 1,
      volume: 0.8
    }, {
      active: true,
      index: 2,
      volume: 0.8
    }, {
      active: true,
      index: 3,
      volume: 0.8
    }, {
      active: true,
      index: 5,
      volume: 0.8
    }, {
      active: true,
      index: 6,
      volume: 0.8
    }, {
      active: true,
      index: 7,
      volume: 0.8
    }, {
      active: true,
      index: 9,
      volume: 0.8
    }, {
      active: true,
      index: 10,
      volume: 0.8
    }, {
      active: true,
      index: 11,
      volume: 0.8
    }, {
      active: true,
      index: 13,
      volume: 0.8
    }, {
      active: true,
      index: 14,
      volume: 0.8
    }, {
      active: true,
      index: 15,
      volume: 0.8
    }]
  }]
};
exports.psyTrancePreset = psyTrancePreset;

},{}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.drumMachineController = drumMachineController;

var _DrumMachine = require("../../audio/DrumMachine");

var _audioLoader = require("../../audio/audio-loader");

var _presets = require("../../audio/presets");

/**
 * ---------------------------------------------------------------------------------------
 * mainController.js
 * ---------------------------------------------------------------------------------------
 */
function drumMachineController($scope, $compile, $http, $interval, serverBaseURL, FileSaver, Blob, socketEvents) {
  var drumMachine = new _DrumMachine.DrumMachine();
  var loadingContainer = $("#loadingContainer");
  var commentsLoadingOverlay = $("#commentsLoadingOverlay");
  var commentsLoadingSpinner = $("#commentsLoadingSpinner");
  var playBtn = $("#sequencerPlayButton");
  var stopBtn = $("#sequencerStopButton");
  var bpmSlider = $("#sequencerBPMslider");

  $scope.safeApply = function (fn) {
    var phase = this.$root.$$phase;

    if (phase == '$apply' || phase == '$digest') {
      if (fn && typeof fn === 'function') {
        fn();
      }
    } else {
      this.$apply(fn);
    }
  };

  $scope.title = "Main Controller";
  $scope.tracks = [];
  $scope.ticksElements = [];
  $scope.audioContext = drumMachine.audioContext;
  $scope.bpm = drumMachine.bpm;
  $scope.isPlaying = drumMachine.isPlaying;
  $scope.isStopped = drumMachine.isStopped;
  $scope.removeTrack = removeTrack;
  $scope.integerval = /^\d*$/;
  $scope.beats = new Array(drumMachine.numberOfBeats).fill(false);
  $scope.samplesData = {};
  $scope.samplesBuffers = {};
  $scope.username = "";
  $scope.commentToPost = "";
  $scope.comments = [];
  $scope.invalidUsernameMessage = "Give ya a name! (3-32 characters)";
  $scope.invalidCommentMessage = "Write something cool! (3-1000 characters)";
  $scope.preset = {
    name: "",
    categorySelected: undefined,
    categories: []
  };
  $scope.tracks = drumMachine.tracks;
  $scope.safeApply();
  /*
   * ---------------------------------------------------------------------------------------
   * UI
   * ---------------------------------------------------------------------------------------
   */

  $("#accordion").accordion({
    animate: 200,
    collapsible: true,
    active: false,
    heightStyle: "content",
    // icons: { "header": "ui-icon-plus", "activeHeader": "ui-icon-minus" },
    beforeActivate: function beforeActivate() {
      if ($scope.comments.length === 0) {
        loadComments();
      }
    }
  });
  $("#postCommentBtn").button({
    icon: "ui-icon-pencil"
  });
  /*
   * ---------------------------------------------------------------------------------------
   * event listeners
   * ---------------------------------------------------------------------------------------
   */

  $(window).ready(function () {
    var beatIndicatorsContainer = document.getElementById("beatIndicators");
    var beatIndicators = beatIndicatorsContainer.getElementsByClassName("beat-indicator");

    function updateBeatIndicators(previousTickIndex, tickIndex) {
      $(beatIndicators[previousTickIndex]).removeClass("beat-indicator-active");
      $(beatIndicators[tickIndex]).addClass("beat-indicator-active");
    }

    drumMachine.addCallBackInLoop(updateBeatIndicators);
  });
  window.addEventListener("keyup", function (e) {
    switch (e.keyCode) {
      //space
      case 32:
        if ($('textarea#commentArea, input#usernameInput, input[name="trackName"], input[name="presetName"]').is(":focus")) {
          e.stopPropagation();
        } else if ($scope.isStopped) {
          play(e);
        } else {
          stop(e);
        }

        break;

      default:
        break;
    }
  });
  window.addEventListener("keydown", function (e) {
    switch (e.keyCode) {
      //space
      case 32:
        if ($('textarea#commentArea, input#usernameInput, input[name="trackName"], input[name="presetName"]').is(":focus")) {
          e.stopPropagation();
        } else {
          e.preventDefault();
          e.stopPropagation();
        }

        break;

      default:
        break;
    }
  }); // remove scroll down on spacebar

  window.addEventListener('keydown', function (e) {
    if (e.keyCode === 32 && e.target === document.body) {
      e.preventDefault();
    }
  });
  /*
   * ---------------------------------------------------------------------------------------
   * public
   * ---------------------------------------------------------------------------------------
   */

  $scope.enableLoadingSpinner = enableLoadingSpinner;
  $scope.disableLoadingSpinner = disableLoadingSpinner;
  $scope.audioLoader = _audioLoader.audioLoader;
  $scope.playSoundFromBuffer = drumMachine.playSoundFromBuffer;

  $scope.startSequencer = function () {
    drumMachine._start();

    $scope.isPlaying = true;
    $scope.isStopped = false;
  };

  $scope.stopSequencer = function () {
    drumMachine._stop();

    $scope.isPlaying = false;
    $scope.isStopped = true;
    var indicators = document.getElementById("beatIndicators").getElementsByClassName("beat-indicator");
    $(indicators).removeClass("beat-indicator-active");
  };

  $scope.addTrack = function () {
    drumMachine.addEmptyTrack();
  };

  $scope.exportMidi = function () {
    var tracks = [];

    for (var key in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(key)) {
        (function () {
          var track = drumMachine.tracks[key];
          var trackData = {
            name: track.name,
            notes: []
          };
          var waitCounter = 0;
          track.ticks.forEach(function (tick) {
            if (tick.active) {
              var noteEventData = {
                pitch: ["C4"],
                velocity: tick.volume,
                duration: "16" // 1/16

              };

              if (waitCounter > 0) {
                var waitParam = "T" + waitCounter * 32; //number of ticks to wait (each tick is 1/128)

                noteEventData["wait"] = waitParam;
              }

              trackData.notes.push(noteEventData);
              waitCounter = 0;
            } else {
              waitCounter += 1;
            }
          });
          tracks.push(trackData);
        })();
      }
    }

    var data = {
      bpm: drumMachine.bpm,
      timeSignature: {
        num: 4,
        den: 4
      },
      tracks: tracks
    };
    $http({
      url: serverBaseURL + '/api/midi',
      method: "POST",
      responseType: "arraybuffer",
      headers: {
        "Content-Type": "application/json"
      },
      data: JSON.stringify(data)
    }).then(function (response) {
      console.log(response);
      var blob = new Blob([response.data], {
        type: 'audio/midi'
      }); // let fileName = response.headers('content-disposition');

      FileSaver.saveAs(blob, "loop.mid");
    }, function (response) {
      console.log(response);
    });
  };

  $scope.populateCategories = function () {
    return new Promise(function (resolve, reject) {
      $http({
        url: serverBaseURL + "/api/categories",
        method: "GET",
        headers: {
          "Accept": "application/json"
        }
      }).then(function (response) {
        // console.log(response);
        var categories = response.data; // categories.forEach(c => {
        //     $scope.categories.push(c.name);
        // });

        $scope.preset.categories = categories;
        resolve(categories);
      }, function (error) {
        console.log(error);
        reject(error);
      });
    });
  };
  /*
  $scope.loadPreset = () => {
        $http({
          url: serverBaseURL + "/api/presets",
          method: "GET",
          headers: {
              "Accept": "application/json"
          }
      }).then(response => {
            let presets = response.data;
          if (presets.length === 0) {
              return;
          }
            drumMachine.loadPreset(presets[0]).then(tracks => {
                tracks.forEach(t => {
                  drumMachine.tracks[t.id] = t;
              });
                $scope.bpm = drumMachine.bpm;
              bpmSlider.slider("value", $scope.bpm);
              $scope.$apply();
              }, error => {
              console.log(error);
          });
        }, errorResponse => {
          console.log(errorResponse);
      });
    };
  */


  $scope.savePreset = function () {
    var formData = new FormData();
    var jsonPreset = drumMachine.buildJsonPreset($scope.preset.name, $scope.preset.categorySelected.name);

    for (var id in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(id)) {
        var track = drumMachine.tracks[id];
        var blob = new Blob([track.sampleData.originalBuffer], {
          // type: track.sampleData.extension ? "audio/" + track.sampleData.extension : "octet-stream"
          type: "octet-stream"
        });
        formData.append("sample", blob, track.sampleData.fileName);
      }
    }

    formData.append("preset", jsonPreset);
    var xhr = new XMLHttpRequest();
    xhr.open('POST', serverBaseURL + '/api/presets', true);
    xhr.setRequestHeader("Accept", "application/json");

    xhr.onload = function () {
      // created
      if (xhr.status === 201) {
        toastOk("Preset saved! ;-)");
        $scope.onPresetCancel();
      } else if (xhr.status === 409) {
        console.log(xhr.response);
        toastError("Preset name " + $scope.preset.name + " already taken for category " + $scope.preset.categorySelected.name);
      } else {
        toastError("Ops! Something went wrong :-(");
        $scope.onPresetCancel();
      }
    };

    xhr.send(formData);
  };

  $scope.uploadFiles = function () {
    var formData = new FormData(); // $('input[type="file"]').each(function(index) {
    //
    //     let fileList = $(this)[0].files;
    //
    //     for(let i = 0; i < fileList.length; i++) {
    //         let file = fileList[i];
    //         formData.append(file.name, file);
    //     }
    // });
    // drumMachine.tracks.forEach(track => {
    //
    //     console.log(track);
    //     let buffer = track.buffer;
    //     let blob = new Blob(buffer);
    //     formData.append(track.name, blob, "campione.wav");
    //
    // });

    for (var id in drumMachine.tracks) {
      if (drumMachine.tracks.hasOwnProperty(id)) {
        var track = drumMachine.tracks[id];
        var blob = new Blob([track.sampleData.originalBuffer], {
          // type: track.sampleData.extension ? "audio/" + track.sampleData.extension : "octet-stream"
          type: "octet-stream"
        });
        formData.append("sample", blob, track.sampleData.fileName);
      }
    }

    var obj = {
      name: "track",
      bpm: 120,
      tracks: [{
        name: "kick"
      }, {
        name: "snare"
      }]
    };
    formData.append("preset", JSON.stringify(obj));
    var xhr = new XMLHttpRequest();
    xhr.open('POST', serverBaseURL + '/api/upload', true);
    xhr.setRequestHeader("Accept", "application/json");
    xhr.onload = handler;
    xhr.send(formData);

    function handler(e) {
      console.log(e);
    } // $http({
    //     url: "http://localhost:4500/upload",
    //     method: "POST",
    //     transformRequest: angular.identity,
    //     header: {
    //         "Content-Type": undefined,
    //     },
    //     data: formData
    // }).then(response => {
    //     console.log(response);
    // }, error => {
    //     console.log(error);
    // });

  };

  $scope.postComment = function () {
    var data = {
      username: $scope.username,
      message: $scope.commentToPost
    };
    $http({
      url: serverBaseURL + '/api/comments',
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      },
      data: JSON.stringify(data)
    }).then(function (response) {
      console.log(response);
    }, function (response) {
      console.log(response);
    });
  };

  $scope.onPresetCancel = function () {
    $(".save-preset-container").remove();
  };

  $scope.onPresetSave = function () {
    $scope.savePreset();
  };
  /*
   * ---------------------------------------------------------------------------------------
   * private
   * ---------------------------------------------------------------------------------------
   */


  function removeTrack(track) {
    drumMachine.removeTrack(track.id);
  }

  function initDefaultTracks($scope, drumMachine) {
    enableLoadingSpinner();

    drumMachine._loadDefaultBuffers().then(function () {
      drumMachine._initDefaultTracks();

      $scope.tracks = drumMachine.tracks;
      $scope.$apply();
      disableLoadingSpinner();
    }, function (error) {
      console.log(error);
    });
  }

  function initDATgui(drumMachine) {
    var gui = new dat.GUI();
    var bpmController = gui.add(drumMachine, "bpm", 50.0, 220.0);
    bpmController.onChange(function (value) {
      drumMachine.bpm = Math.floor(drumMachine.bpm);
    });
  }

  function initSequencerControls(scope, drumMachine) {
    playBtn.on("mousedown touchstart", function (e) {
      e.preventDefault();
      e.stopPropagation();
      playBtn.css({
        backgroundColor: "#444"
      });
    });
    playBtn.on("mouseup touchend", function (e) {
      play(e);
    });
    stopBtn.on("mousedown touchstart", function (e) {
      e.preventDefault();
      e.stopPropagation();
      stopBtn.css({
        backgroundColor: "#444"
      });
    });
    stopBtn.on("mouseup touchend", function (e) {
      stop(e);
    });
    bpmSlider.slider({
      min: drumMachine.bpmMin,
      max: drumMachine.bpmMax,
      orientation: "horizontal",
      value: scope.bpm,
      slide: function slide(event, ui) {
        drumMachine.bpm = ui.value;
        scope.bpm = ui.value;
        scope.$apply();
      }
    }).draggable();

    scope.updateSlider = function () {
      if (drumMachine.isInRangeBPM(scope.bpm)) {
        bpmSlider.slider("value", scope.bpm);
        drumMachine.bpm = scope.bpm;
      }
    };
  }

  function play(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    } // playBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Play-50-green.png)"
    // });
    //
    // stopBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Stop-50-white.png)"
    // });


    stopBtn.removeClass("sequencer-stop-active");
    playBtn.removeClass("sequencer-play-inactive");
    stopBtn.addClass("sequencer-stop-inactive");
    playBtn.addClass("sequencer-play-active");
    playBtn.css({
      backgroundColor: "transparent"
    });
    stopBtn.css({
      backgroundColor: "transparent"
    });
    $scope.startSequencer();
  }

  function stop(e) {
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    } // stopBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Stop-50-red.png)"
    // });
    //
    // playBtn.css({
    //     backgroundColor: "transparent",
    //     backgroundImage: "url(./app/assets/icons/Play-50-white.png)"
    // });


    playBtn.removeClass("sequencer-play-active");
    stopBtn.removeClass("sequencer-stop-inactive");
    playBtn.addClass("sequencer-play-inactive");
    stopBtn.addClass("sequencer-stop-active");
    playBtn.css({
      backgroundColor: "transparent"
    });
    stopBtn.css({
      backgroundColor: "transparent"
    });
    $scope.stopSequencer();
  }

  function loadPreset(data) {
    window.scrollTo(0, 0);
    enableLoadingSpinner();
    drumMachine.loadPreset(data).then(function (tracks) {
      tracks.forEach(function (t) {
        drumMachine.tracks[t.id] = t;
      });
      $scope.bpm = drumMachine.bpm;
      bpmSlider.slider("value", $scope.bpm);
      $scope.preset.name = data.name;
      $("#presetTitle").text($scope.preset.name);
      $scope.safeApply();
      disableLoadingSpinner();
    }, function (error) {
      console.log(error);
    });
  }

  function initExportMidiMenu() {
    var API = $("nav#menu").data("mmenu");
    var li = $('<li><a href="#exportMidi" >Export midi</a></li>');
    li.click($scope.exportMidi);
    $("#menu-list").find(".mm-listview").append(li);
    API.initPanels($("#menu-list"));
  }

  function initPresetsMenu(categories) {
    $('li[id="presetsMenu"]').remove();
    $http({
      url: serverBaseURL + "/api/presets",
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    }).then(function (response) {
      var presetsData = response.data;

      if (presetsData.length === 0) {
        return;
      }

      var liParent = $('<li id="presetsMenu"><a href="#">Presets</a></li>');
      var ulParent = $("<ul></ul>");
      liParent.append(ulParent);
      categories.forEach(function (category) {
        var match = presetsData.find(function (e) {
          return e._id === category.name;
        });

        if (!match) {
          return;
        }

        var categoryPresets = match.presets;
        var liCategory = $('<li><a href="#">' + category.name + '</a></li>');
        var ul = $("<ul></ul>");
        categoryPresets.forEach(function (preset) {
          var li = $('<li><a href="#">' + preset.name + '</a></li>');
          li.click(function () {
            loadPreset(preset);
          });
          ul.append(li);
        });
        liCategory.append(ul);
        ulParent.append(liCategory);
      });
      var API = $("nav#menu").data("mmenu");
      $("#menu-list").find(".mm-listview li:first").after(liParent);
      API.initPanels($("#menu-list"));
    }, function (errorResponse) {
      console.log(errorResponse);
      initExportMidiMenu();
    });
  }

  function initSavePresetMenu() {
    var li = $('<li><a href="#">Save preset</a></li>');
    li.click(function () {
      var savePreset = angular.element(document.createElement('save-preset'));
      var domElem = $compile(savePreset)($scope);
      angular.element(document.body).append(domElem);
    });
    var API = $("nav#menu").data("mmenu");
    $("#menu-list").find(".mm-listview").append(li);
    API.initPanels($("#menu-list"));
  }

  function loadComments() {
    enableCommentsLoadingSpinner();
    $http({
      url: serverBaseURL + '/api/comments',
      method: "GET",
      headers: {
        "Accept": "application/json"
      }
    }).then(function (response) {
      console.log(response);
      $scope.comments = response.data;
      $scope.safeApply();
      disableCommentsLoadingSpinner();
    }, function (response) {
      console.log(response);
    });
  }

  function enableLoadingSpinner() {
    setTimeout(function () {
      window.scrollTo(0, 0);
      loadingContainer.addClass("loading-active");
    }, 0);
  }

  function disableLoadingSpinner() {
    setTimeout(function () {
      window.scrollTo(0, 0);
      loadingContainer.removeClass("loading-active");
    }, 1500);
  }

  function enableCommentsLoadingSpinner() {
    setTimeout(function () {
      commentsLoadingOverlay.addClass("loading-active");
      commentsLoadingSpinner.addClass("loading-active");
    }, 0);
  }

  function disableCommentsLoadingSpinner() {
    setTimeout(function () {
      commentsLoadingOverlay.removeClass("loading-active");
      commentsLoadingSpinner.removeClass("loading-active");
    }, 100);
  }

  function toastError(text) {
    $.toast({
      text: text,
      showHideTransition: 'slide',
      // It can be plain, fade or slide
      bgColor: '#ff4a40',
      // Background color for toast
      textColor: '#fff',
      // text color
      allowToastClose: false,
      // Show the close button or not
      hideAfter: 3000,
      // `false` to make it sticky or time in miliseconds to hide after
      stack: 5,
      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once
      textAlign: 'left',
      // Alignment of text i.e. left, right, center
      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page

    });
  }

  function toastOk(text) {
    $.toast({
      text: text,
      showHideTransition: 'slide',
      // It can be plain, fade or slide
      bgColor: '#05a2fc',
      // Background color for toast
      textColor: '#fff',
      // text color
      allowToastClose: false,
      // Show the close button or not
      hideAfter: 3000,
      // `false` to make it sticky or time in miliseconds to hide after
      stack: 5,
      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once
      textAlign: 'left',
      // Alignment of text i.e. left, right, center
      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page

    });
  }
  /**
   * ---------------------------------------------------------------------------------------
   * init
   * ---------------------------------------------------------------------------------------
   */


  var socket = io.connect(serverBaseURL);
  initSequencerControls($scope, drumMachine);
  loadPreset(_presets.groovyRockPreset);
  window.scrollTo(0, 0);
  $(window).ready(function () {
    window.scrollTo(0, 0);
    initSavePresetMenu();
    initExportMidiMenu();
    $scope.populateCategories().then(function (categories) {
      initPresetsMenu(categories);
    });
    $interval(function () {
      $scope.populateCategories().then(function (categories) {
        console.log("$interval: populateCategories");
      });
    }, 20000);
    socket.on(socketEvents.newPreset, function (data) {
      console.log(socketEvents.newPreset, data);
      initPresetsMenu($scope.preset.categories);
    });
    socket.on(socketEvents.newComment, function (comment) {
      // toastOk("Comment posted!");
      $scope.comments.splice(0, 0, comment);
      $scope.commentToPost = "";
      $scope.commentForm.$setPristine();
      $scope.safeApply();
    });
  });
}

},{"../../audio/DrumMachine":2,"../../audio/audio-loader":5,"../../audio/presets":6}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.testController = testController;

/*
 * ---------------------------------------------------------------------------------------
 * testController.js
 * ---------------------------------------------------------------------------------------
 */
function testController($scope) {
  $scope.title = "Test Controller";
  console.log("Test Controller");
}

},{}],9:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * commentDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.commentDirective = commentDirective;

function commentDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    templateUrl: "app/directives/templates/commentDirective.html",
    link: function link(scope, elem, attrs) {}
  };
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadSamples = loadSamples;

var _audioLoader = require("../audio/audio-loader");

/**
 * ---------------------------------------------------------------------------------------
 * loadSoundsDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

function loadSamples($http, supportedAudioFormats) {
  var serverBaseURL = "http://192.168.1.75:4500";
  return {
    restrict: 'AE',
    replace: 'false',
    // scope: {
    //     samplesData: "="
    // },
    templateUrl: "app/directives/templates/loadSamples.html",
    link: function link(scope, elem, attrs) {
      /*
       * ---------------------------------------------------------------------------------------
       * styles & widgets
       * ---------------------------------------------------------------------------------------
       */
      function initUI() {
        $(".samples-accordion").accordion({
          animate: 200,
          collapsible: true,
          active: false,
          heightStyle: "content"
        });
        elem.find('button[name="playSampleButton"]').button({
          icon: "ui-icon-circle-triangle-e",
          showLabel: false
        });
        elem.find('button[name="loadSampleButton"]').button({
          icon: "ui-icon-check",
          showLabel: false
        });
        elem.find('button[id="samplesCancelBtn"]').button();
        elem.css("display", "block");
        scope.disableLoadingSpinner();
      }
      /*
       * ---------------------------------------------------------------------------------------
       * event listeners
       * ---------------------------------------------------------------------------------------
       */


      function addEvents() {}
      /*
       * ---------------------------------------------------------------------------------------
       * functions
       * ---------------------------------------------------------------------------------------
       */


      scope.close = function () {
        $("#angularView").css("display", "block");
        elem.remove();
      };

      scope.playSampleFromServer = function (sample) {
        if (!sample) return;

        if (scope.samplesBuffers.hasOwnProperty(sample.path)) {
          var buffer = scope.samplesBuffers[sample.path];
          scope.playSoundFromBuffer(buffer);
        } else {
          scope.audioLoader(scope.audioContext, sample.path).then(function (buffer) {
            scope.samplesBuffers[sample.path] = buffer;
            scope.playSoundFromBuffer(buffer);
          });
        }
      };

      scope.loadSampleOnTrack = function (sample) {
        if (!sample) return;
        (0, _audioLoader.getArrayBuffer)(scope.audioContext, sample.path).then(function (arrayBuffer) {
          scope.track.setSampleData(sample.name, arrayBuffer);
          scope.close();
        });
      };
      /*
       * ---------------------------------------------------------------------------------------
       * init
       * ---------------------------------------------------------------------------------------
       */


      function init() {
        // hide content behind
        $("#angularView").css("display", "none");
        var intervalID = setInterval(function () {
          var result = $(".samples-accordion");

          if (result.length > 0) {
            clearInterval(intervalID);
            initUI();
            addEvents();
          }
        }, 200);
      }

      init();
    }
  };
}

},{"../audio/audio-loader":5}],11:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * savePresetDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.savePresetDirective = savePresetDirective;

function savePresetDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    templateUrl: "app/directives/templates/savePreset.html",
    link: function link(scope, elem, attrs) {
      scope.tagHandler = function (tag) {
        return null;
      };

      scope.invalidPresetNameMessage = "Choose a preset name (4-24 characters)";
      scope.invalidCategoryMessage = "Choose a category";

      function initUI() {
        $("#presetCancelBtn").button();
        $("#presetSaveBtn").button();
      }
      /**
       * ---------------------------------------------------------------------------------------
       * init
       * ---------------------------------------------------------------------------------------
       */


      initUI();
    }
  };
}

},{}],12:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * tickSliderDirective.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tickSliderDirective = tickSliderDirective;

function tickSliderDirective() {
  return {
    restrict: 'AE',
    replace: 'false',
    scope: {
      tick: "=",
      ticksElements: "=",
      resizeTick: "="
    },
    link: function link(scope, elem, attrs) {
      // console.log(scope.tick);
      scope.ticksElements.push(elem);
      elem.slider({
        min: 0,
        max: 100,
        orientation: "vertical",
        value: scope.tick.active ? scope.tick.volume * 100 : 0,
        slide: function slide(event, ui) {
          if (ui.value === 0) {
            scope.tick.active = false;
          } else {
            scope.tick.active = true;
          }

          scope.tick.volume = ui.value * 0.01; // console.log(scope.tick.volume);
        }
      }).draggable(); // scope.resizeTick(elem);
    }
  };
}

},{}],13:[function(require,module,exports){
/**
 * ---------------------------------------------------------------------------------------
 * trackDirective
 * ---------------------------------------------------------------------------------------
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.trackDirective = trackDirective;

var _utils = require("../utils/utils");

function trackDirective($http, $compile, supportedAudioFormats) {
  return {
    restrict: 'AE',
    replace: 'false',
    scope: {
      track: "=",
      ticksElements: "=",
      samplesData: "=",
      samplesBuffers: "=",
      removeTrack: "=",
      audioContext: "=",
      audioLoader: "=",
      playSoundFromBuffer: "=",
      enableLoadingSpinner: "=",
      disableLoadingSpinner: "="
    },
    templateUrl: "app/directives/templates/trackDirective.html",
    link: function link(scope, elem, attrs) {
      var serverBaseURL = "http://192.168.1.75:4500";
      scope.resizeTick = resizeTick;
      scope.handleFiles = handleFiles;
      scope.playSound = playSound;
      scope.onSoloTrack = onSoloTrack;
      scope.onMuteTrack = onMuteTrack;
      scope.loadSamplesFromServer = loadSamplesFromServer;
      /*
       * ---------------------------------------------------------------------------------------
       * styles & widgets
       * ---------------------------------------------------------------------------------------
       */

      elem.find('button[name="removeTrackButton"]').button({
        icon: "ui-icon-close",
        showLabel: false
      });
      elem.find('button[name="playSoundButton"]').button({
        icon: "ui-icon-circle-triangle-e",
        showLabel: false
      });
      elem.find('button[name="loadSoundFromServerBtn"]').button();
      elem.find('div[id="trackVolumeSlider"]').slider({
        min: 0,
        max: 100,
        orientation: "horizontal",
        value: scope.track.gainNode.gain.value * 100,
        slide: function slide(event, ui) {
          scope.track.gainNode.gain.value = ui.value * 0.01;
        }
      }).draggable();

      if (scope.track.pannerNodeSupported) {
        elem.find('div[id="trackPanSlider"]').slider({
          min: -100,
          max: 100,
          orientation: "horizontal",
          value: scope.track.pannerNode.pan.value * 100,
          slide: function slide(event, ui) {
            scope.track.pannerNode.pan.value = ui.value * 0.01;
          }
        }).draggable();
      } else {
        elem.find('div[id="trackPanSlider"]').remove();
        elem.find(".pan-label").remove(); // push down volume slider

        elem.find('div[id="trackVolumeSlider"]').css({// marginTop: 0,
          // position: "relative",
          // bottom: 0
        });
      }

      elem.find('button[name="soloTrackButton"]').button();
      elem.find('button[name="muteTrackButton"]').button();
      elem.find('button[name="loadSoundFromServerBtn"]').button({
        showLabel: false,
        icon: "ui-icon-volume-on"
      });
      /*
       * ---------------------------------------------------------------------------------------
       * event listeners
       * ---------------------------------------------------------------------------------------
       */

      scope.$on("$destroy", function () {
        elem.unbind("dragover", onDragOver);
        elem.unbind("drop", onDrop);
        elem.unbind("dragleave", onDragLeave);
      });
      elem.on("dragover", onDragOver);
      elem.on("drop", onDrop);
      elem.on("dragleave", onDragLeave);
      /*
       * ---------------------------------------------------------------------------------------
       * private functions
       * ---------------------------------------------------------------------------------------
       */

      function resizeTick(tickElem) {
        var ticksContainerWidth = elem.find(".ticks-container").width();
        console.log(ticksContainerWidth);
        var margin = 8;
        var tickWidth = Math.floor((ticksContainerWidth - 15 * margin) / 16.0); // tickElem.css({
        //     width: 32,
        //     marginRight: "8px !important"
        // });
        // tickElem.parent().css({
        //     width: tickWidth,
        //     marginRight: margin
        // });
        // tickElem.find(".ui-slider-handle").css({
        //
        // });
      }

      function handleFiles(files) {
        if (!files || files.length < 1) return;
        var file = files[0];
        var fileExtension = (0, _utils.getFileExtension)(file.name); // chech if it is an audio file with a supported extension

        if (!supportedAudioFormats.has(fileExtension)) {
          console.log("File format not supported by Web Audio API: ", fileExtension);
          return;
        }

        var reader = new FileReader();

        reader.onload = function (ev) {
          var arrayBuffer = ev.target.result;
          scope.track.setSampleData(file.name, arrayBuffer);
        };

        reader.readAsArrayBuffer(file);
      }

      function onDragOver(e) {
        if (!elem.hasClass("track-dragfile")) {
          elem.addClass("track-dragfile");
        }

        e.stopPropagation();
        e.preventDefault();
      }

      function onDrop(e) {
        e.stopPropagation();
        e.preventDefault();
        handleFiles(e.originalEvent.dataTransfer.files);
        onDragLeave();
      }

      function onDragLeave(e) {
        if (elem.hasClass("track-dragfile")) {
          elem.removeClass("track-dragfile");
        }

        if (e) {
          e.stopPropagation();
          e.preventDefault();
        }
      }

      function playSound() {
        scope.track.playLoadedSample();
      }

      function onSoloTrack() {
        scope.track.drumMachine.soloTrack(scope.track.id);
      }

      function onMuteTrack() {
        scope.track.drumMachine.muteTrack(scope.track.id);
      }

      function loadSamplesFromServer() {
        scope.enableLoadingSpinner();
        $http({
          url: serverBaseURL + "/api/samples",
          method: "GET",
          headers: {
            "Accept": "application/json"
          }
        }).then(function (response) {
          scope.samplesData = response.data;
          var loadSamplesElem = $('<load-samples></load-samples>');
          var el = $compile(loadSamplesElem)(scope);
          $("body").append(el);
        });
      }
    }
  };
}

},{"../utils/utils":15}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initRoutes = initRoutes;

/*
 * ---------------------------------------------------------------------------------------
 * routes.js
 * ---------------------------------------------------------------------------------------
 */
function initRoutes($routeProvider) {
  $routeProvider.when('/', {
    controller: "drumMachineController",
    templateUrl: "app/components/drum-machine/drumMachineView.html"
  });
  $routeProvider.when('/test', {
    controller: "testController",
    templateUrl: "app/components/test/testView.html"
  });
  $routeProvider.otherwise({
    redirectTo: '/'
  });
}

},{}],15:[function(require,module,exports){
/*
 * ---------------------------------------------------------------------------------------
 * utils.js
 * ---------------------------------------------------------------------------------------
 */
"use strict";
/*
 * checkIfiOSdevice
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.checkIfiOSdevice = checkIfiOSdevice;
exports.guid = guid;
exports.getExtensionFromFileName = getExtensionFromFileName;
exports.getFileNameFromPath = getFileNameFromPath;
exports.getArrayAudioBufferFromUrl = getArrayAudioBufferFromUrl;
exports.getFileExtension = getFileExtension;

function checkIfiOSdevice() {
  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
}
/*
 * generate uuid
 */


function guid() {
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return uuid;
}

function getExtensionFromFileName(fileName) {
  var re = /(?:\.([^.]+))?$/;
  var ext = re.exec(fileName)[1];
  return ext;
}

function getFileNameFromPath(path) {
  return path.replace(/^.*[\\\/]/, '');
}

function getArrayAudioBufferFromUrl(audioCtx, url) {
  return new Promise(function (resolve, reject) {
    if (!audioCtx) {
      reject("Missing audio context parameter.");
      return;
    }

    if (!url) {
      reject("Missing url parameter");
      return;
    }

    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "arraybuffer";

    xhr.onload = function () {
      resolve(xhr.response);
    };

    xhr.send();
  });
}

function getFileExtension(fileName) {
  return fileName.substr(fileName.lastIndexOf('.') + 1);
}

},{}]},{},[1]);

//# sourceMappingURL=app.bundle.min.js.map
