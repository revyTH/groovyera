{"version":3,"names":[],"mappings":"","sources":["app.bundle.min.js"],"sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n},{}],2:[function(require,module,exports){\n/*\n * ---------------------------------------------------------------------------------------\n * app.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nvar _routes = require(\"./routes\");\n\nvar _drumMachineController = require(\"./components/drum-machine/drumMachineController\");\n\nvar _testController = require(\"./components/test/testController\");\n\nvar _trackDirective = require(\"./directives/trackDirective\");\n\nvar _tickSliderDirective = require(\"./directives/tickSliderDirective\");\n\nvar _commentDirective = require(\"./directives/commentDirective\");\n\nvar _savePresetDirective = require(\"./directives/savePresetDirective\");\n\nvar _loadSamples = require(\"./directives/loadSamples\");\n\nrequire(\"regenerator-runtime/runtime\");\n\n(function () {\n  var app = angular.module(\"myApp\", [\"ngRoute\", \"ngFileSaver\", \"ngSanitize\", \"ui.select\"]); // configure angular routes\n\n  app.config([\"$routeProvider\", _routes.initRoutes]); // bind controllers\n\n  app.controller(\"drumMachineController\", [\"$scope\", \"$compile\", \"$http\", \"$interval\", \"serverBaseURL\", \"FileSaver\", \"Blob\", \"socketEvents\", _drumMachineController.drumMachineController]);\n  app.controller(\"testController\", ['$scope', _testController.testController]); // register directives\n\n  app.directive(\"tickSlider\", _tickSliderDirective.tickSliderDirective);\n  app.directive(\"theTrack\", [\"$http\", \"$compile\", \"supportedAudioFormats\", _trackDirective.trackDirective]);\n  app.directive(\"comment\", _commentDirective.commentDirective);\n  app.directive(\"savePreset\", _savePresetDirective.savePresetDirective);\n  app.directive(\"loadSamples\", [\"$http\", \"supportedAudioFormats\", _loadSamples.loadSamples]);\n  var supportedAudioFormats = new Set();\n  supportedAudioFormats.add(\"wav\");\n  supportedAudioFormats.add(\"audio/wav\");\n  supportedAudioFormats.add(\"audio/x-wav\");\n  supportedAudioFormats.add(\"mp3\");\n  supportedAudioFormats.add(\"audio/mp3\");\n  supportedAudioFormats.add(\"audio/x-mp3\");\n  supportedAudioFormats.add(\"ogg\");\n  supportedAudioFormats.add(\"audio/ogg\");\n  supportedAudioFormats.add(\"audio/x-ogg\");\n  var socketEvents = {\n    newPreset: \"NEW_PRESET\",\n    newComment: \"NEW_COMMENT\"\n  }; // constants\n\n  app.constant(\"serverBaseURL\", \"http://localhost:4500\");\n  app.constant(\"supportedAudioFormats\", supportedAudioFormats);\n  app.constant(\"socketEvents\", socketEvents);\n})();\n\n},{\"./components/drum-machine/drumMachineController\":8,\"./components/test/testController\":9,\"./directives/commentDirective\":10,\"./directives/loadSamples\":11,\"./directives/savePresetDirective\":12,\"./directives/tickSliderDirective\":13,\"./directives/trackDirective\":14,\"./routes\":15,\"regenerator-runtime/runtime\":1}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DrumMachine = void 0;\n\nvar _audioLoader = require(\"./audio-loader\");\n\nvar _utils = require(\"../utils/utils\");\n\nvar _Track = require(\"./Track\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DrumMachine =\n/*#__PURE__*/\nfunction () {\n  function DrumMachine() {\n    _classCallCheck(this, DrumMachine);\n\n    this.tag = \"[DrumMachine.js]\";\n    this.numberOfBeats = 16;\n    var AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.audioContext = new AudioContext();\n    this.pannerNodeSupported = false;\n    this.bpm = 120;\n    this.bpmMin = 30;\n    this.bpmMax = 240;\n    this.timeSignature = {\n      num: 4,\n      den: 4\n    };\n    this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note\n\n    this.isPlaying = false;\n    this.isStopped = true;\n    this.buffers = {};\n    this.tracks = {}; // this.defaultBuffersLoaded = false;\n    // this.defaultTracksLoaded = false;\n\n    this._tracksInSolo = new Set();\n    this._tracksInMute = new Set();\n    this.currentTickIndex = 0;\n    this.callBacksInLoop = [];\n    this.soundURLs = {\n      kick: \"app/assets/audio/kick.wav\",\n      snare: \"app/assets/audio/snare.wav\",\n      hat: \"app/assets/audio/hat.wav\",\n      ride: \"app/assets/audio/ride.wav\"\n    };\n\n    if ((0, _utils.checkIfiOSdevice)()) {\n      this._enableAudioContextForiOS();\n    } else {\n      this.audioContextEnabled = true;\n    }\n\n    if (typeof this.audioContext.createStereoPanner === \"function\") {\n      this.pannerNodeSupported = true;\n      console.log(\"Stereo panner supported\");\n    } else {\n      console.log(\"Stereo panner not supported\");\n    }\n  }\n  /*\n   * get bpm\n   */\n\n\n  _createClass(DrumMachine, [{\n    key: \"_enableAudioContextForiOS\",\n    value: function _enableAudioContextForiOS() {\n      var _this = this;\n\n      $(document).ready(function () {\n        var btn = $(\"<button/>\", {\n          visibility: \"hidden\"\n        });\n        btn.on(\"touchstart\", function () {\n          var buffer = _this.audioContext.createBuffer(1, 1, 22050);\n\n          var source = _this.audioContext.createBufferSource();\n\n          source.buffer = buffer;\n          source.start();\n          _this.audioContextEnabled = true;\n          console.log(\"AudioContext enabled for iOS\");\n        });\n        btn.trigger(\"touchstart\");\n      });\n    }\n    /*\n    _loadDefaultBuffers() {\n         let ctx = this.audioContext;\n        let urls = this.soundURLs;\n         return new Promise((resolve, reject) => {\n            Promise.all([\n                audioLoader(ctx, urls.kick),\n                audioLoader(ctx, urls.snare),\n                audioLoader(ctx, urls.hat),\n                audioLoader(ctx, urls.ride)\n            ]).then(values => {\n                this.buffers[\"kick\"] = values[0];\n                this.buffers[\"snare\"] = values[1];\n                this.buffers[\"hat\"] = values[2];\n                this.buffers[\"ride\"] = values[3];\n                this.defaultBuffersLoaded = true;\n                console.log(this.buffers);\n                 this.defaultBuffersLoaded = true;\n                console.log(\"Default buffers loaded\");\n                // this._initDefaultTracks();\n                 resolve(\"Default buffers loaded\");\n             }, error => {\n                reject(error);\n            });\n        });\n    }\n      _initDefaultTracks() {\n         if (!this.defaultBuffersLoaded) {\n            return;\n        }\n         this.tracks = {};\n         let kickTrack = new Track(this, \"kick\", this.buffers[\"kick\"]);\n        kickTrack.setTicksFromArray([0,4,8,12]);\n        let snareTrack = new Track(this, \"snare\", this.buffers[\"snare\"], 1, 0.1);\n        snareTrack.setTicksFromArray([4,12]);\n        let hatTrack = new Track(this, \"hat\", this.buffers[\"hat\"], 0.85, -1);\n        // hatTrack.setTicksFromArray([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]);\n          hatTrack.setTicksFromArray([\n            {\n                active: true,\n                index: 0,\n                volume: 0.5\n            },\n            {\n                active: true,\n                index: 1,\n                volume: 0.5\n            },\n            {\n                active: true,\n                index: 2,\n                volume: 1.2\n            },\n            {\n                active: true,\n                index: 3,\n                volume: 0.4\n            },\n            {\n                active: true,\n                index: 4,\n                volume: 0.9\n            },\n            {\n                active: true,\n                index: 5,\n                volume: 0.5\n            },\n            {\n                active: true,\n                index: 6,\n                volume: 1\n            },\n            {\n                active: true,\n                index: 7,\n                volume: 0.4\n            },\n            {\n                active: true,\n                index: 8,\n                volume: 0.9\n            },\n            {\n                active: true,\n                index: 9,\n                volume: 0.5\n            },\n            {\n                active: true,\n                index: 10,\n                volume: 1\n            },\n            {\n                active: true,\n                index: 11,\n                volume: 0.4\n            },\n            {\n                active: true,\n                index: 12,\n                volume: 0.9\n            },\n            {\n                active: true,\n                index: 13,\n                volume: 0.5\n            },\n            {\n                active: true,\n                index: 14,\n                volume: 1\n            },\n            {\n                active: true,\n                index: 15,\n                volume: 0.4\n            }\n        ]);\n         this.tracks[kickTrack.id] = kickTrack;\n        this.tracks[snareTrack.id] = snareTrack;\n        this.tracks[hatTrack.id] = hatTrack;\n         this.defaultTracksLoaded = true;\n        console.log(\"Default tracks loaded\" , this.tracks);\n         // this._start();\n    }\n    */\n\n  }, {\n    key: \"_onBpmChanged\",\n    value: function _onBpmChanged() {\n      this.tickTime = 60.0 / this.bpm / 4.0; // 1/16 note\n    }\n  }, {\n    key: \"_start\",\n    value: function _start() {\n      if (!this.audioContextEnabled) {\n        console.log(\"Cannot play: AudioContext is not enabled.\");\n        return;\n      }\n\n      if (this.isPlaying) {\n        console.log(\"Cannot play: it is already playing.\");\n        return;\n      }\n\n      this.isStopped = false;\n      var self = this;\n      var ctx = this.audioContext;\n      var startTime = ctx.currentTime;\n      var nextTickTime = startTime + self.tickTime;\n      var index = 0;\n      var timeOutID;\n      var firstLoopEnded = false;\n\n      function scheduler() {\n        if (self.isStopped) {\n          clearTimeout(timeOutID);\n          self.isPlaying = false;\n          return;\n        }\n\n        if (nextTickTime <= ctx.currentTime + self.tickTime) {\n          self.isPlaying = true;\n          self.isStopped = false;\n          $.each(self.tracks, function (id, track) {\n            if (track.mute) {\n              return;\n            }\n\n            if (!track.sampleData.decodedAudioBuffer) {\n              return;\n            }\n\n            var trackTick = track.ticks[index];\n\n            if (!trackTick.active) {\n              return;\n            }\n\n            var tickSound = ctx.createBufferSource();\n            tickSound.buffer = track.sampleData.decodedAudioBuffer;\n            var tickGainNode = ctx.createGain();\n            tickSound.connect(tickGainNode);\n            tickGainNode.gain.value = trackTick.volume;\n            tickGainNode.connect(track.gainNode);\n            tickSound.start(nextTickTime);\n          });\n          self.currentTickIndex = index;\n          var previousIndex = index === 0 ? self.numberOfBeats - 1 : index - 1;\n          var previousPrevious = previousIndex === 0 ? self.numberOfBeats - 1 : previousIndex - 1; // to syncronize web audio api schedule with ui beat indicators\n\n          if (firstLoopEnded) {\n            self.callBacksInLoop.forEach(function (fn) {\n              fn(previousPrevious, previousIndex);\n            });\n          }\n\n          nextTickTime += self.tickTime;\n          index = ++index === self.numberOfBeats ? 0 : index;\n        }\n\n        firstLoopEnded = true;\n        timeOutID = window.setTimeout(scheduler, 0);\n      }\n\n      scheduler();\n    }\n  }, {\n    key: \"_stop\",\n    value: function _stop() {\n      this.isStopped = true;\n    }\n  }, {\n    key: \"_playSound\",\n    value: function _playSound(bufferName, time) {\n      var ctx = this.audioContext;\n      var sound = ctx.createBufferSource();\n      sound.buffer = this.buffers[bufferName];\n      sound.connect(ctx.destination);\n      sound.start(time);\n    }\n  }, {\n    key: \"playSoundFromBuffer\",\n    value: function playSoundFromBuffer(buffer, time) {\n      if (!buffer) return;\n      var ctx = this.audioContext;\n      var sound = ctx.createBufferSource();\n      sound.buffer = buffer;\n      sound.connect(ctx.destination);\n\n      if (time) {\n        sound.start(time);\n      } else {\n        sound.start();\n      }\n    }\n  }, {\n    key: \"removeTrack\",\n    value: function removeTrack(trackID) {\n      var track = this.tracks[trackID];\n\n      this._tracksInSolo[\"delete\"](track);\n\n      this._tracksInMute[\"delete\"](track);\n\n      delete this.tracks[trackID];\n    }\n  }, {\n    key: \"soloTrack\",\n    value: function soloTrack(trackID) {\n      if (!this.tracks.hasOwnProperty(trackID)) return;\n      var focusTrack = this.tracks[trackID];\n      var tracksInSolo = this._tracksInSolo;\n      var tracksInMute = this._tracksInMute; // case 1: track is not in solo and not in mute\n\n      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {\n        tracksInSolo.add(focusTrack);\n        focusTrack.solo = true;\n        focusTrack.mute = false;\n        $.each(this.tracks, function (id, track) {\n          if (id === trackID) {\n            return;\n          }\n\n          if (!tracksInSolo.has(track)) {\n            tracksInMute.add(track);\n            track.mute = true;\n            track.solo = false;\n          }\n        });\n      } // case 2: track is in solo\n      else if (tracksInSolo.has(focusTrack)) {\n          tracksInSolo[\"delete\"](focusTrack);\n          focusTrack.solo = false;\n\n          if (tracksInSolo.size > 0) {\n            tracksInMute.add(focusTrack);\n            focusTrack.mute = true;\n          } else {\n            tracksInMute.clear();\n            tracksInSolo.clear();\n            $.each(this.tracks, function (id, track) {\n              track.mute = false;\n              track.solo = false;\n            });\n          }\n        } // case 3: track is in mute\n        else {\n            tracksInSolo.add(focusTrack);\n            focusTrack.solo = true;\n            focusTrack.mute = false;\n\n            if (tracksInSolo.size === 1) {\n              $.each(this.tracks, function (id, track) {\n                if (id !== trackID) {\n                  tracksInMute.add(track);\n                  track.mute = true;\n                }\n              });\n            }\n          }\n    }\n  }, {\n    key: \"muteTrack\",\n    value: function muteTrack(trackID) {\n      if (!this.tracks.hasOwnProperty(trackID)) return;\n      var focusTrack = this.tracks[trackID];\n      var tracksInSolo = this._tracksInSolo;\n      var tracksInMute = this._tracksInMute; // case 1: track not in solo or mute\n\n      if (!tracksInSolo.has(focusTrack) && !tracksInMute.has(focusTrack)) {\n        tracksInMute.add(focusTrack);\n        focusTrack.mute = true;\n        focusTrack.solo = false;\n      } // case 2: track is in solo\n      else if (tracksInSolo.has(focusTrack)) {\n          tracksInSolo[\"delete\"](focusTrack);\n          tracksInMute.add(focusTrack);\n          focusTrack.solo = false;\n          focusTrack.mute = true;\n\n          if (tracksInSolo.size === 0) {\n            $.each(this.tracks, function (id, track) {\n              if (id !== trackID) {\n                tracksInMute[\"delete\"](track);\n                track.mute = false;\n              }\n            });\n          }\n        } // case 3: track is in mute\n        else if (tracksInMute.has(focusTrack)) {\n            if (tracksInSolo.size > 0) {\n              tracksInMute[\"delete\"](focusTrack);\n              tracksInSolo.add(focusTrack);\n              focusTrack.mute = false;\n              focusTrack.solo = true;\n            } else {\n              tracksInMute[\"delete\"](focusTrack);\n              focusTrack.mute = false;\n            }\n          }\n    }\n  }, {\n    key: \"addCallBackInLoop\",\n    value: function addCallBackInLoop(fn) {\n      if (!_typeof(fn) === \"function\") return;\n      this.callBacksInLoop.push(fn);\n    }\n  }, {\n    key: \"isInRangeBPM\",\n    value: function isInRangeBPM(value) {\n      if (value >= this.bpmMin && value <= this.bpmMax) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"_createEmptyTicksArray\",\n    value: function _createEmptyTicksArray() {\n      var ticks = [];\n\n      for (var i = 0; i < this.numberOfBeats; i++) {\n        ticks.push({\n          index: i,\n          volume: 0,\n          active: false\n        });\n      }\n\n      return ticks;\n    }\n  }, {\n    key: \"_clearTracks\",\n    value: function _clearTracks() {\n      this._tracksInSolo.clear();\n\n      this._tracksInMute.clear();\n\n      for (var key in this.tracks) {\n        if (this.tracks.hasOwnProperty(key)) {\n          delete this.tracks[key];\n        }\n      }\n    }\n  }, {\n    key: \"addEmptyTrack\",\n    value: function addEmptyTrack() {\n      var name = \"track_\" + (Object.keys(this.tracks).length + 1);\n      var track = new _Track.Track(this, name);\n      track.setTicksFromArray(this._createEmptyTicksArray());\n      this.tracks[track.id] = track;\n    }\n  }, {\n    key: \"createTrack\",\n    value: function createTrack(name, soundPath, volume, pan, ticks) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var track = new _Track.Track(_this2, name, soundPath);\n\n        if (ticks) {\n          track.setTicksFromArray(ticks);\n        } else {\n          track.setTicksFromArray(_this2._createEmptyTicksArray());\n        }\n\n        if (volume) {\n          track.gainNode.gain.value = volume;\n        }\n\n        if (pan) {\n          if (track.pannerNode) {\n            track.pannerNode.pan.value = pan;\n          }\n        }\n\n        resolve(track);\n      });\n    }\n  }, {\n    key: \"loadPreset\",\n    value: function loadPreset(data) {\n      var _this3 = this;\n\n      try {\n        this.bpm = data.bpm;\n\n        this._clearTracks();\n\n        var promises = [];\n        data.tracks.forEach(function (track) {\n          promises.push(_this3.createTrack(track.name, track.soundPath, track.volume, track.pan, track.ticks));\n        });\n        return Promise.all(promises);\n      } catch (e) {\n        return new Promise(function (resolve, reject) {\n          reject(e);\n        });\n      }\n    }\n  }, {\n    key: \"buildJsonPreset\",\n    value: function buildJsonPreset(name, category) {\n      var _this4 = this;\n\n      var data = {\n        name: name,\n        category: category,\n        bpm: this.bpm,\n        timeSignature: this.timeSignature\n      };\n      var tracks = [];\n\n      for (var id in this.tracks) {\n        if (this.tracks.hasOwnProperty(id)) {\n          (function () {\n            var track = _this4.tracks[id];\n            var trackData = {\n              name: track.name,\n              soundPath: category + \"/\" + track.sampleData.fileName,\n              volume: track.gainNode.gain.value,\n              pan: _this4.pannerNodeSupported ? track.pannerNode.pan.value : 0\n            };\n            var ticksData = [];\n            track.ticks.forEach(function (tick) {\n              ticksData.push({\n                active: tick.active,\n                index: tick.index,\n                volume: tick.volume\n              });\n            });\n            trackData.ticks = ticksData;\n            tracks.push(trackData);\n          })();\n        }\n      }\n\n      data.tracks = tracks;\n      return JSON.stringify(data);\n    }\n  }, {\n    key: \"bpm\",\n    get: function get() {\n      return this._bpm;\n    }\n    /*\n     * set bpm\n     */\n    ,\n    set: function set(val) {\n      if (val !== this._bpm) {\n        this._bpm = val;\n\n        this._onBpmChanged();\n      }\n    }\n  }]);\n\n  return DrumMachine;\n}();\n\nexports.DrumMachine = DrumMachine;\n\n},{\"../utils/utils\":16,\"./Track\":5,\"./audio-loader\":6}],4:[function(require,module,exports){\n/*\n * ---------------------------------------------------------------------------------------\n * Tick.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Tick = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Tick = function Tick() {\n  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;\n\n  _classCallCheck(this, Tick);\n\n  this.index = index;\n  this.active = active;\n  this.volume = volume;\n} // get volume() {\n//     return this._volume;\n// }\n//\n// set volume(val) {\n//     this._volume = val > 1 ? 1.0 : val;\n// }\n;\n\nexports.Tick = Tick;\n\n},{}],5:[function(require,module,exports){\n/*\n * ---------------------------------------------------------------------------------------\n * Track.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Track = void 0;\n\nvar _Tick = require(\"./Tick\");\n\nvar _utils = require(\"../utils/utils\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Track =\n/*#__PURE__*/\nfunction () {\n  function Track(drumMachine) {\n    var _this = this;\n\n    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"track_default\";\n    var soundPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;\n    var pan = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var mute = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, Track);\n\n    this.id = (0, _utils.guid)();\n    this.drumMachine = drumMachine;\n    this.audioContext = drumMachine.audioContext;\n    this.name = name;\n    this.sampleData = {\n      fileName: \"\",\n      extension: \"\",\n      originalBuffer: undefined,\n      decodedAudioBuffer: undefined\n    };\n    this.solo = false;\n    this.mute = mute;\n    this.ticks = [];\n    this.pannerNodeSupported = false;\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.gain.value = volume;\n\n    if (drumMachine.pannerNodeSupported) {\n      this.pannerNode = this.audioContext.createStereoPanner();\n      this.pannerNode.pan.value = pan;\n      this.gainNode.connect(this.pannerNode);\n      this.pannerNode.connect(this.audioContext.destination);\n      this.pannerNodeSupported = true;\n    } else {\n      this.gainNode.connect(this.audioContext.destination);\n    }\n\n    if (soundPath) {\n      (0, _utils.getArrayAudioBufferFromUrl)(this.audioContext, soundPath).then(function (buffer) {\n        var fileName = (0, _utils.getFileNameFromPath)(soundPath);\n\n        _this.setSampleData(fileName, buffer);\n      });\n    }\n\n    this._initTicks();\n  } // setGain(val) {\n  //     this.gainNode.gain.value = val > 1 ? 1.0 : val;\n  // }\n  // setPan(val) {\n  //     if (val < -1) {\n  //         this.pannerNode.pan.value = -1;\n  //     }\n  //     else if (val > 1) {\n  //         this.pannerNode.pan.value = 1;\n  //     }\n  //     else {\n  //         this.pannerNode.pan.value = val;\n  //     }\n  // }\n\n  /*\n   *\n   */\n\n\n  _createClass(Track, [{\n    key: \"_initTicks\",\n    value: function _initTicks() {\n      this.ticks = [];\n\n      for (var i = 0; i < this.drumMachine.numberOfBeats; ++i) {\n        this.ticks.push(new _Tick.Tick(i));\n      }\n    }\n  }, {\n    key: \"setTick\",\n    value: function setTick(index) {\n      var active = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var volume = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;\n\n      if (index < 0 || index > this.drumMachine.numberOfBeats - 1) {\n        return;\n      }\n\n      this.ticks[index].volume = volume;\n      this.ticks[index].active = active;\n    }\n  }, {\n    key: \"setTicksFromArray\",\n    value: function setTicksFromArray(data) {\n      var _this2 = this;\n\n      data.forEach(function (e) {\n        if (_typeof(e) === \"object\") {\n          if (e.index === \"undefined\" || e.index < 0 || e.index > _this2.drumMachine.numberOfBeats - 1) {\n            return;\n          }\n\n          _this2.ticks[e.index].volume = e.volume !== \"undefined\" ? e.volume : 0;\n          _this2.ticks[e.index].active = e.active !== \"undefined\" ? e.active : false;\n        } else {\n          _this2.ticks[e].active = true;\n        }\n      });\n    }\n  }, {\n    key: \"setBuffer\",\n    value: function setBuffer(arrayBuffer, fileName) {\n      var _this3 = this;\n\n      this.originalBuffer = arrayBuffer;\n      this.drumMachine.audioContext.decodeAudioData(arrayBuffer, function (decodedAudioBuffer) {\n        _this3.buffer = decodedAudioBuffer;\n        console.log(\"Track \" + _this3.name + \": audio buffer changed ( \" + fileName + \" )\");\n      });\n    }\n  }, {\n    key: \"playLoadedSample\",\n    value: function playLoadedSample() {\n      if (!this.audioContext || !this.sampleData.decodedAudioBuffer) return;\n      var sound = this.audioContext.createBufferSource();\n      sound.buffer = this.sampleData.decodedAudioBuffer;\n      sound.connect(this.audioContext.destination);\n      sound.start();\n    }\n  }, {\n    key: \"setSampleData\",\n    value: function setSampleData(fileName, arrayAudioBuffer) {\n      var _this4 = this;\n\n      if (!fileName || !arrayAudioBuffer) {\n        console.log(\"Missing fileName and/or arrayAudioBuffer parameters\");\n        return;\n      }\n\n      this.drumMachine.audioContext.decodeAudioData(arrayAudioBuffer, function (decodedBuffer) {\n        _this4.sampleData.fileName = fileName;\n        _this4.sampleData.extension = (0, _utils.getExtensionFromFileName)(fileName);\n        _this4.sampleData.originalBuffer = arrayAudioBuffer;\n        _this4.sampleData.decodedAudioBuffer = decodedBuffer;\n      });\n    }\n  }]);\n\n  return Track;\n}();\n\nexports.Track = Track;\n\n},{\"../utils/utils\":16,\"./Tick\":4}],6:[function(require,module,exports){\n/*\n * ---------------------------------------------------------------------------------------\n * audio-loader.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.audioLoader = audioLoader;\nexports.getArrayBuffer = getArrayBuffer;\n\nfunction audioLoader(audioCtx, url) {\n  return new Promise(function (resolve, reject) {\n    if (!audioCtx) {\n      reject(\"Missing audio context parameter.\");\n      return;\n    }\n\n    if (!url) {\n      reject(\"Missing url parameter\");\n      return;\n    }\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.responseType = \"arraybuffer\";\n\n    xhr.onload = function () {\n      try {\n        audioCtx.decodeAudioData(xhr.response, function (decodedBuffer) {\n          resolve(decodedBuffer);\n        });\n      } catch (e) {\n        reject(e);\n      }\n    };\n\n    xhr.send();\n  });\n}\n\nfunction getArrayBuffer(audioCtx, url) {\n  return new Promise(function (resolve, reject) {\n    if (!audioCtx) {\n      reject(\"Missing audio context parameter.\");\n      return;\n    }\n\n    if (!url) {\n      reject(\"Missing url parameter\");\n      return;\n    }\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.responseType = \"arraybuffer\";\n\n    xhr.onload = function () {\n      resolve(xhr.response);\n    };\n\n    xhr.send();\n  });\n}\n\n},{}],7:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.psyTrancePreset = exports.groovyRockPreset = void 0;\n\n/**\n * ---------------------------------------------------------------------------------------\n * presets.js\n * ---------------------------------------------------------------------------------------\n */\nvar groovyRockPreset = {\n  name: \"Straight rock\",\n  bpm: 120,\n  category: \"rock\",\n  timeSignature: {\n    num: 4,\n    den: 4\n  },\n  tracks: [{\n    name: \"kick\",\n    soundPath: \"app/assets/samples/rock/rock-kick.wav\",\n    volume: 1,\n    pan: 0,\n    ticks: [{\n      active: true,\n      index: 0,\n      volume: 1\n    }, {\n      active: true,\n      index: 8,\n      volume: 1\n    }, {\n      active: true,\n      index: 10,\n      volume: 1\n    }]\n  }, {\n    name: \"snare\",\n    soundPath: \"app/assets/samples/rock/rock-snare.wav\",\n    volume: 1,\n    pan: 0,\n    ticks: [{\n      active: true,\n      index: 4,\n      volume: 1\n    }, {\n      active: true,\n      index: 12,\n      volume: 1\n    }]\n  }, {\n    name: \"hh open\",\n    soundPath: \"app/assets/samples/rock/rock-hh-open.wav\",\n    volume: 0.4,\n    pan: 0.4,\n    ticks: [{\n      active: true,\n      index: 4,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 8,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 12,\n      volume: 0.8\n    }]\n  }, {\n    name: \"crash\",\n    soundPath: \"app/assets/samples/rock/rock-crash.wav\",\n    volume: 0.5,\n    pan: -0.5,\n    ticks: [{\n      active: true,\n      index: 0,\n      volume: 0.8\n    }]\n  }]\n};\nexports.groovyRockPreset = groovyRockPreset;\nvar psyTrancePreset = {\n  name: \"psy-trance\",\n  category: \"trance\",\n  bpm: 145,\n  timeSignature: {\n    num: 4,\n    den: 4\n  },\n  tracks: [{\n    name: \"kick\",\n    soundPath: \"app/assets/samples/trance/trance-kick.wav\",\n    volume: 1,\n    pan: 0,\n    ticks: [{\n      active: true,\n      index: 0,\n      volume: 1\n    }, {\n      active: true,\n      index: 4,\n      volume: 1\n    }, {\n      active: true,\n      index: 8,\n      volume: 1\n    }, {\n      active: true,\n      index: 12,\n      volume: 1\n    }]\n  }, {\n    name: \"clap\",\n    soundPath: \"app/assets/samples/trance/trance-clap.wav\",\n    volume: 1,\n    pan: 0,\n    ticks: [{\n      active: true,\n      index: 4,\n      volume: 1\n    }, {\n      active: true,\n      index: 12,\n      volume: 1\n    }]\n  }, {\n    name: \"hh open\",\n    soundPath: \"app/assets/samples/trance/trance-hh-open.wav\",\n    volume: 0.8,\n    pan: 0.2,\n    ticks: [{\n      active: true,\n      index: 2,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 6,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 10,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 14,\n      volume: 0.8\n    }]\n  }, {\n    name: \"bass\",\n    soundPath: \"app/assets/samples/trance/trance-bass-A1.wav\",\n    volume: 0.8,\n    pan: 0,\n    ticks: [{\n      active: true,\n      index: 1,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 2,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 3,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 5,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 6,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 7,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 9,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 10,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 11,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 13,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 14,\n      volume: 0.8\n    }, {\n      active: true,\n      index: 15,\n      volume: 0.8\n    }]\n  }]\n};\nexports.psyTrancePreset = psyTrancePreset;\n\n},{}],8:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.drumMachineController = drumMachineController;\n\nvar _DrumMachine = require(\"../../audio/DrumMachine\");\n\nvar _audioLoader = require(\"../../audio/audio-loader\");\n\nvar _presets = require(\"../../audio/presets\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction drumMachineController($scope, $compile, $http, $interval, serverBaseURL, FileSaver, Blob, socketEvents) {\n  var drumMachine = new _DrumMachine.DrumMachine();\n  var loadingContainer = $(\"#loadingContainer\");\n  var commentsLoadingOverlay = $(\"#commentsLoadingOverlay\");\n  var commentsLoadingSpinner = $(\"#commentsLoadingSpinner\");\n  var playBtn = $(\"#sequencerPlayButton\");\n  var stopBtn = $(\"#sequencerStopButton\");\n  var bpmSlider = $(\"#sequencerBPMslider\");\n\n  $scope.safeApply = function (fn) {\n    var phase = this.$root.$$phase;\n\n    if (phase == '$apply' || phase == '$digest') {\n      if (fn && typeof fn === 'function') {\n        fn();\n      }\n    } else {\n      this.$apply(fn);\n    }\n  };\n\n  $scope.title = \"Main Controller\";\n  $scope.tracks = [];\n  $scope.ticksElements = [];\n  $scope.audioContext = drumMachine.audioContext;\n  $scope.bpm = drumMachine.bpm;\n  $scope.isPlaying = drumMachine.isPlaying;\n  $scope.isStopped = drumMachine.isStopped;\n  $scope.removeTrack = removeTrack;\n  $scope.integerval = /^\\d*$/;\n  $scope.beats = new Array(drumMachine.numberOfBeats).fill(false);\n  $scope.samplesData = {};\n  $scope.samplesBuffers = {};\n  $scope.username = \"\";\n  $scope.commentToPost = \"\";\n  $scope.comments = [];\n  $scope.invalidUsernameMessage = \"Give ya a name! (3-32 characters)\";\n  $scope.invalidCommentMessage = \"Write something cool! (3-1000 characters)\";\n  $scope.preset = {\n    name: \"\",\n    categorySelected: undefined,\n    categories: []\n  };\n  $scope.tracks = drumMachine.tracks;\n  $scope.safeApply();\n  /*\n   * ---------------------------------------------------------------------------------------\n   * UI\n   * ---------------------------------------------------------------------------------------\n   */\n\n  $(\"#accordion\").accordion({\n    animate: 200,\n    collapsible: true,\n    active: false,\n    heightStyle: \"content\",\n    // icons: { \"header\": \"ui-icon-plus\", \"activeHeader\": \"ui-icon-minus\" },\n    beforeActivate: function beforeActivate() {\n      if ($scope.comments.length === 0) {\n        loadComments();\n      }\n    }\n  });\n  $(\"#postCommentBtn\").button({\n    icon: \"ui-icon-pencil\"\n  });\n  /*\n   * ---------------------------------------------------------------------------------------\n   * event listeners\n   * ---------------------------------------------------------------------------------------\n   */\n\n  $(window).ready(function () {\n    var beatIndicatorsContainer = document.getElementById(\"beatIndicators\");\n    var beatIndicators = beatIndicatorsContainer.getElementsByClassName(\"beat-indicator\");\n\n    function updateBeatIndicators(previousTickIndex, tickIndex) {\n      $(beatIndicators[previousTickIndex]).removeClass(\"beat-indicator-active\");\n      $(beatIndicators[tickIndex]).addClass(\"beat-indicator-active\");\n    }\n\n    drumMachine.addCallBackInLoop(updateBeatIndicators);\n  });\n  window.addEventListener(\"keyup\", function (e) {\n    switch (e.keyCode) {\n      //space\n      case 32:\n        if ($('textarea#commentArea, input#usernameInput, input[name=\"trackName\"], input[name=\"presetName\"]').is(\":focus\")) {\n          e.stopPropagation();\n        } else if ($scope.isStopped) {\n          play(e);\n        } else {\n          stop(e);\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  });\n  window.addEventListener(\"keydown\", function (e) {\n    switch (e.keyCode) {\n      //space\n      case 32:\n        if ($('textarea#commentArea, input#usernameInput, input[name=\"trackName\"], input[name=\"presetName\"]').is(\":focus\")) {\n          e.stopPropagation();\n        } else {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  });\n  window.addEventListener('keydown', function (e) {\n    if (e.keyCode === 32 && e.target === document.body) {\n      e.preventDefault();\n    }\n  }); // remove scroll down on spacebar\n\n  /*\n   * ---------------------------------------------------------------------------------------\n   * public\n   * ---------------------------------------------------------------------------------------\n   */\n\n  $scope.enableLoadingSpinner = enableLoadingSpinner;\n  $scope.disableLoadingSpinner = disableLoadingSpinner;\n  $scope.audioLoader = _audioLoader.audioLoader;\n  $scope.playSoundFromBuffer = drumMachine.playSoundFromBuffer;\n\n  $scope.startSequencer = function () {\n    drumMachine._start();\n\n    $scope.isPlaying = true;\n    $scope.isStopped = false;\n  };\n\n  $scope.stopSequencer = function () {\n    drumMachine._stop();\n\n    $scope.isPlaying = false;\n    $scope.isStopped = true;\n    var indicators = document.getElementById(\"beatIndicators\").getElementsByClassName(\"beat-indicator\");\n    $(indicators).removeClass(\"beat-indicator-active\");\n  };\n\n  $scope.addTrack = function () {\n    drumMachine.addEmptyTrack();\n  };\n\n  $scope.exportMidi = function () {\n    var tracks = [];\n\n    for (var key in drumMachine.tracks) {\n      if (drumMachine.tracks.hasOwnProperty(key)) {\n        (function () {\n          var track = drumMachine.tracks[key];\n          var trackData = {\n            name: track.name,\n            notes: []\n          };\n          var waitCounter = 0;\n          track.ticks.forEach(function (tick) {\n            if (tick.active) {\n              var noteEventData = {\n                pitch: [\"C4\"],\n                velocity: tick.volume,\n                duration: \"16\" // 1/16\n\n              };\n\n              if (waitCounter > 0) {\n                var waitParam = \"T\" + waitCounter * 32; //number of ticks to wait (each tick is 1/128)\n\n                noteEventData[\"wait\"] = waitParam;\n              }\n\n              trackData.notes.push(noteEventData);\n              waitCounter = 0;\n            } else {\n              waitCounter += 1;\n            }\n          });\n          tracks.push(trackData);\n        })();\n      }\n    }\n\n    var data = {\n      bpm: drumMachine.bpm,\n      timeSignature: {\n        num: 4,\n        den: 4\n      },\n      tracks: tracks\n    };\n    $http({\n      url: serverBaseURL + '/api/midi',\n      method: \"POST\",\n      responseType: \"arraybuffer\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      data: JSON.stringify(data)\n    }).then(function (response) {\n      console.log(response);\n      var blob = new Blob([response.data], {\n        type: 'audio/midi'\n      }); // let fileName = response.headers('content-disposition');\n\n      FileSaver.saveAs(blob, \"loop.mid\");\n    }, function (response) {\n      console.log(response);\n    });\n  };\n\n  $scope.populateCategories = function () {\n    return new Promise(function (resolve, reject) {\n      $http({\n        url: serverBaseURL + \"/api/categories\",\n        method: \"GET\",\n        headers: {\n          \"Accept\": \"application/json\"\n        }\n      }).then(function (response) {\n        // console.log(response);\n        var categories = response.data; // categories.forEach(c => {\n        //     $scope.categories.push(c.name);\n        // });\n\n        $scope.preset.categories = categories;\n        resolve(categories);\n      }, function (error) {\n        console.log(error);\n        reject(error);\n      });\n    });\n  };\n  /*\n  $scope.loadPreset = () => {\n       $http({\n          url: serverBaseURL + \"/api/presets\",\n          method: \"GET\",\n          headers: {\n              \"Accept\": \"application/json\"\n          }\n      }).then(response => {\n           let presets = response.data;\n          if (presets.length === 0) {\n              return;\n          }\n           drumMachine.loadPreset(presets[0]).then(tracks => {\n               tracks.forEach(t => {\n                  drumMachine.tracks[t.id] = t;\n              });\n               $scope.bpm = drumMachine.bpm;\n              bpmSlider.slider(\"value\", $scope.bpm);\n              $scope.$apply();\n            }, error => {\n              console.log(error);\n          });\n       }, errorResponse => {\n          console.log(errorResponse);\n      });\n   };\n  */\n\n\n  $scope.savePreset = function () {\n    var formData = new FormData();\n    var jsonPreset = drumMachine.buildJsonPreset($scope.preset.name, $scope.preset.categorySelected.name);\n\n    for (var id in drumMachine.tracks) {\n      if (drumMachine.tracks.hasOwnProperty(id)) {\n        var track = drumMachine.tracks[id];\n        var blob = new Blob([track.sampleData.originalBuffer], {\n          // type: track.sampleData.extension ? \"audio/\" + track.sampleData.extension : \"octet-stream\"\n          type: \"octet-stream\"\n        });\n        formData.append(\"sample\", blob, track.sampleData.fileName);\n      }\n    }\n\n    formData.append(\"preset\", jsonPreset);\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', serverBaseURL + '/api/presets', true);\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n\n    xhr.onload = function () {\n      // created\n      if (xhr.status === 201) {\n        toastOk(\"Preset saved! ;-)\");\n        $scope.onPresetCancel();\n      } else if (xhr.status === 409) {\n        console.log(xhr.response);\n        toastError(\"Preset name \" + $scope.preset.name + \" already taken for category \" + $scope.preset.categorySelected.name);\n      } else {\n        toastError(\"Ops! Something went wrong :-(\");\n        $scope.onPresetCancel();\n      }\n    };\n\n    xhr.send(formData);\n  };\n\n  $scope.uploadFiles = function () {\n    var formData = new FormData(); // $('input[type=\"file\"]').each(function(index) {\n    //\n    //     let fileList = $(this)[0].files;\n    //\n    //     for(let i = 0; i < fileList.length; i++) {\n    //         let file = fileList[i];\n    //         formData.append(file.name, file);\n    //     }\n    // });\n    // drumMachine.tracks.forEach(track => {\n    //\n    //     console.log(track);\n    //     let buffer = track.buffer;\n    //     let blob = new Blob(buffer);\n    //     formData.append(track.name, blob, \"campione.wav\");\n    //\n    // });\n\n    for (var id in drumMachine.tracks) {\n      if (drumMachine.tracks.hasOwnProperty(id)) {\n        var track = drumMachine.tracks[id];\n        var blob = new Blob([track.sampleData.originalBuffer], {\n          // type: track.sampleData.extension ? \"audio/\" + track.sampleData.extension : \"octet-stream\"\n          type: \"octet-stream\"\n        });\n        formData.append(\"sample\", blob, track.sampleData.fileName);\n      }\n    }\n\n    var obj = {\n      name: \"track\",\n      bpm: 120,\n      tracks: [{\n        name: \"kick\"\n      }, {\n        name: \"snare\"\n      }]\n    };\n    formData.append(\"preset\", JSON.stringify(obj));\n    var xhr = new XMLHttpRequest();\n    xhr.open('POST', serverBaseURL + '/api/upload', true);\n    xhr.setRequestHeader(\"Accept\", \"application/json\");\n    xhr.onload = handler;\n    xhr.send(formData);\n\n    function handler(e) {\n      console.log(e);\n    } // $http({\n    //     url: \"http://localhost:4500/upload\",\n    //     method: \"POST\",\n    //     transformRequest: angular.identity,\n    //     header: {\n    //         \"Content-Type\": undefined,\n    //     },\n    //     data: formData\n    // }).then(response => {\n    //     console.log(response);\n    // }, error => {\n    //     console.log(error);\n    // });\n\n  };\n\n  $scope.postComment = function () {\n    var data = {\n      username: $scope.username,\n      message: $scope.commentToPost\n    };\n    $http({\n      url: serverBaseURL + '/api/comments',\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Accept\": \"application/json\"\n      },\n      data: JSON.stringify(data)\n    }).then(function (response) {\n      console.log(response);\n    }, function (response) {\n      console.log(response);\n    });\n  };\n\n  $scope.onPresetCancel = function () {\n    $(\".save-preset-container\").remove();\n  };\n\n  $scope.onPresetSave = function () {\n    $scope.savePreset();\n  };\n  /*\n   * ---------------------------------------------------------------------------------------\n   * private\n   * ---------------------------------------------------------------------------------------\n   */\n\n\n  function removeTrack(track) {\n    drumMachine.removeTrack(track.id);\n  }\n\n  function initDefaultTracks($scope, drumMachine) {\n    enableLoadingSpinner();\n\n    drumMachine._loadDefaultBuffers().then(function () {\n      drumMachine._initDefaultTracks();\n\n      $scope.tracks = drumMachine.tracks;\n      $scope.$apply();\n      disableLoadingSpinner();\n    }, function (error) {\n      console.log(error);\n    });\n  }\n\n  function initDATgui(drumMachine) {\n    var gui = new dat.GUI();\n    var bpmController = gui.add(drumMachine, \"bpm\", 50.0, 220.0);\n    bpmController.onChange(function (value) {\n      drumMachine.bpm = Math.floor(drumMachine.bpm);\n    });\n  }\n\n  function initSequencerControls(scope, drumMachine) {\n    playBtn.on(\"mousedown touchstart\", function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      playBtn.css({\n        backgroundColor: \"#444\"\n      });\n    });\n    playBtn.on(\"mouseup touchend\", function (e) {\n      play(e);\n    });\n    stopBtn.on(\"mousedown touchstart\", function (e) {\n      e.preventDefault();\n      e.stopPropagation();\n      stopBtn.css({\n        backgroundColor: \"#444\"\n      });\n    });\n    stopBtn.on(\"mouseup touchend\", function (e) {\n      stop(e);\n    });\n    bpmSlider.slider({\n      min: drumMachine.bpmMin,\n      max: drumMachine.bpmMax,\n      orientation: \"horizontal\",\n      value: scope.bpm,\n      slide: function slide(event, ui) {\n        drumMachine.bpm = ui.value;\n        scope.bpm = ui.value;\n        scope.$apply();\n      }\n    }).draggable();\n\n    scope.updateSlider = function () {\n      if (drumMachine.isInRangeBPM(scope.bpm)) {\n        bpmSlider.slider(\"value\", scope.bpm);\n        drumMachine.bpm = scope.bpm;\n      }\n    };\n  }\n\n  function play(e) {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    } // playBtn.css({\n    //     backgroundColor: \"transparent\",\n    //     backgroundImage: \"url(./app/assets/icons/Play-50-green.png)\"\n    // });\n    //\n    // stopBtn.css({\n    //     backgroundColor: \"transparent\",\n    //     backgroundImage: \"url(./app/assets/icons/Stop-50-white.png)\"\n    // });\n\n\n    stopBtn.removeClass(\"sequencer-stop-active\");\n    playBtn.removeClass(\"sequencer-play-inactive\");\n    stopBtn.addClass(\"sequencer-stop-inactive\");\n    playBtn.addClass(\"sequencer-play-active\");\n    playBtn.css({\n      backgroundColor: \"transparent\"\n    });\n    stopBtn.css({\n      backgroundColor: \"transparent\"\n    });\n    $scope.startSequencer();\n  }\n\n  function stop(e) {\n    if (e) {\n      e.preventDefault();\n      e.stopPropagation();\n    } // stopBtn.css({\n    //     backgroundColor: \"transparent\",\n    //     backgroundImage: \"url(./app/assets/icons/Stop-50-red.png)\"\n    // });\n    //\n    // playBtn.css({\n    //     backgroundColor: \"transparent\",\n    //     backgroundImage: \"url(./app/assets/icons/Play-50-white.png)\"\n    // });\n\n\n    playBtn.removeClass(\"sequencer-play-active\");\n    stopBtn.removeClass(\"sequencer-stop-inactive\");\n    playBtn.addClass(\"sequencer-play-inactive\");\n    stopBtn.addClass(\"sequencer-stop-active\");\n    playBtn.css({\n      backgroundColor: \"transparent\"\n    });\n    stopBtn.css({\n      backgroundColor: \"transparent\"\n    });\n    $scope.stopSequencer();\n  }\n\n  function loadPreset(data) {\n    window.scrollTo(0, 0);\n    enableLoadingSpinner();\n    drumMachine.loadPreset(data).then(function (tracks) {\n      tracks.forEach(function (t) {\n        drumMachine.tracks[t.id] = t;\n      });\n      $scope.bpm = drumMachine.bpm;\n      bpmSlider.slider(\"value\", $scope.bpm);\n      $scope.preset.name = data.name;\n      $(\"#presetTitle\").text($scope.preset.name);\n      $scope.safeApply();\n      disableLoadingSpinner();\n    }, function (error) {\n      console.log(error);\n    });\n  }\n\n  function initExportMidiMenu() {\n    var API = $(\"nav#menu\").data(\"mmenu\");\n    var li = $('<li><a href=\"#exportMidi\" >Export midi</a></li>');\n    li.click($scope.exportMidi);\n    $(\"#menu-list\").find(\".mm-listview\").append(li);\n    API.initPanels($(\"#menu-list\"));\n  }\n\n  function initPresetsMenu(_x) {\n    return _initPresetsMenu.apply(this, arguments);\n  }\n\n  function _initPresetsMenu() {\n    _initPresetsMenu = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(categories) {\n      var response, presetsData, liParent, ulParent, API;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.next = 3;\n              return $http({\n                url: serverBaseURL + \"/api/presets\",\n                method: \"GET\",\n                headers: {\n                  \"Accept\": \"application/json\"\n                }\n              });\n\n            case 3:\n              response = _context.sent;\n              _context.next = 10;\n              break;\n\n            case 6:\n              _context.prev = 6;\n              _context.t0 = _context[\"catch\"](0);\n              console.error(_context.t0);\n              return _context.abrupt(\"return\");\n\n            case 10:\n              presetsData = response.data;\n\n              if (!(presetsData.length === 0)) {\n                _context.next = 13;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 13:\n              $('li[id=\"presetsMenu\"]').remove();\n              liParent = $('<li id=\"presetsMenu\"><a href=\"#\">Presets</a></li>');\n              ulParent = $(\"<ul></ul>\");\n              liParent.append(ulParent);\n              categories.forEach(function (category) {\n                var matches = presetsData.filter(function (p) {\n                  return p.category === category.name;\n                });\n                if (!matches.length) return;\n                var liCategory = $('<li><a href=\"#\">' + category.name + '</a></li>');\n                var ul = $(\"<ul></ul>\");\n                matches.forEach(function (preset) {\n                  var li = $('<li><a href=\"#\">' + preset.name + '</a></li>');\n                  li.click(function () {\n                    loadPreset(preset);\n                  });\n                  ul.append(li);\n                });\n                liCategory.append(ul);\n                ulParent.append(liCategory);\n              });\n              API = $(\"nav#menu\").data(\"mmenu\");\n              $(\"#menu-list\").find(\".mm-listview li:first\").after(liParent);\n              API.initPanels($(\"#menu-list\"));\n\n            case 21:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 6]]);\n    }));\n    return _initPresetsMenu.apply(this, arguments);\n  }\n\n  function initSavePresetMenu() {\n    var li = $('<li><a href=\"#\">Save preset</a></li>');\n    li.click(function () {\n      var savePreset = angular.element(document.createElement('save-preset'));\n      var domElem = $compile(savePreset)($scope);\n      angular.element(document.body).append(domElem);\n    });\n    var API = $(\"nav#menu\").data(\"mmenu\");\n    $(\"#menu-list\").find(\".mm-listview\").append(li);\n    API.initPanels($(\"#menu-list\"));\n  }\n\n  function loadComments() {\n    return _loadComments.apply(this, arguments);\n  }\n\n  function _loadComments() {\n    _loadComments = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee2() {\n      var response;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              enableCommentsLoadingSpinner();\n              _context2.prev = 1;\n              _context2.next = 4;\n              return $http({\n                url: serverBaseURL + '/api/comments',\n                method: \"GET\",\n                headers: {\n                  \"Accept\": \"application/json\"\n                }\n              });\n\n            case 4:\n              response = _context2.sent;\n              _context2.next = 11;\n              break;\n\n            case 7:\n              _context2.prev = 7;\n              _context2.t0 = _context2[\"catch\"](1);\n              console.error(_context2.t0);\n              return _context2.abrupt(\"return\");\n\n            case 11:\n              $scope.comments = response.data;\n              $scope.safeApply();\n              disableCommentsLoadingSpinner();\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[1, 7]]);\n    }));\n    return _loadComments.apply(this, arguments);\n  }\n\n  function enableLoadingSpinner() {\n    setTimeout(function () {\n      window.scrollTo(0, 0);\n      loadingContainer.addClass(\"loading-active\");\n    }, 0);\n  }\n\n  function disableLoadingSpinner() {\n    setTimeout(function () {\n      window.scrollTo(0, 0);\n      loadingContainer.removeClass(\"loading-active\");\n    }, 1500);\n  }\n\n  function enableCommentsLoadingSpinner() {\n    setTimeout(function () {\n      commentsLoadingOverlay.addClass(\"loading-active\");\n      commentsLoadingSpinner.addClass(\"loading-active\");\n    }, 0);\n  }\n\n  function disableCommentsLoadingSpinner() {\n    setTimeout(function () {\n      commentsLoadingOverlay.removeClass(\"loading-active\");\n      commentsLoadingSpinner.removeClass(\"loading-active\");\n    }, 100);\n  }\n\n  function toastError(text) {\n    $.toast({\n      text: text,\n      showHideTransition: 'slide',\n      // It can be plain, fade or slide\n      bgColor: '#ff4a40',\n      // Background color for toast\n      textColor: '#fff',\n      // text color\n      allowToastClose: false,\n      // Show the close button or not\n      hideAfter: 3000,\n      // `false` to make it sticky or time in miliseconds to hide after\n      stack: 5,\n      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once\n      textAlign: 'left',\n      // Alignment of text i.e. left, right, center\n      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page\n\n    });\n  }\n\n  function toastOk(text) {\n    $.toast({\n      text: text,\n      showHideTransition: 'slide',\n      // It can be plain, fade or slide\n      bgColor: '#05a2fc',\n      // Background color for toast\n      textColor: '#fff',\n      // text color\n      allowToastClose: false,\n      // Show the close button or not\n      hideAfter: 3000,\n      // `false` to make it sticky or time in miliseconds to hide after\n      stack: 5,\n      // `fakse` to show one stack at a time count showing the number of toasts that can be shown at once\n      textAlign: 'left',\n      // Alignment of text i.e. left, right, center\n      position: 'top-right' // bottom-left or bottom-right or bottom-center or top-left or top-right or top-center or mid-center or an object representing the left, right, top, bottom values to position the toast on page\n\n    });\n  }\n  /**\n   * ---------------------------------------------------------------------------------------\n   * init\n   * ---------------------------------------------------------------------------------------\n   */\n\n\n  var socket = io.connect(serverBaseURL);\n  initSequencerControls($scope, drumMachine);\n  loadPreset(_presets.groovyRockPreset);\n  window.scrollTo(0, 0);\n  $(window).ready(function () {\n    window.scrollTo(0, 0);\n    initSavePresetMenu();\n    initExportMidiMenu();\n    $scope.populateCategories().then(function (categories) {\n      initPresetsMenu(categories);\n    });\n    $interval(function () {\n      $scope.populateCategories().then(function (categories) {\n        console.log(\"$interval: populateCategories\");\n      });\n    }, 20000);\n    socket.on(socketEvents.newPreset, function (data) {\n      console.log(socketEvents.newPreset, data);\n      initPresetsMenu($scope.preset.categories);\n    });\n    socket.on(socketEvents.newComment, function (comment) {\n      // toastOk(\"Comment posted!\");\n      $scope.comments.splice(0, 0, comment);\n      $scope.commentToPost = \"\";\n      $scope.commentForm.$setPristine();\n      $scope.safeApply();\n    });\n  });\n}\n\n},{\"../../audio/DrumMachine\":3,\"../../audio/audio-loader\":6,\"../../audio/presets\":7}],9:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.testController = testController;\n\n/*\n * ---------------------------------------------------------------------------------------\n * testController.js\n * ---------------------------------------------------------------------------------------\n */\nfunction testController($scope) {\n  $scope.title = \"Test Controller\";\n  console.log(\"Test Controller\");\n}\n\n},{}],10:[function(require,module,exports){\n/**\n * ---------------------------------------------------------------------------------------\n * commentDirective.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.commentDirective = commentDirective;\n\nfunction commentDirective() {\n  return {\n    restrict: 'AE',\n    replace: 'false',\n    templateUrl: \"app/directives/templates/commentDirective.html\",\n    link: function link(scope, elem, attrs) {}\n  };\n}\n\n},{}],11:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadSamples = loadSamples;\n\nvar _audioLoader = require(\"../audio/audio-loader\");\n\n/**\n * ---------------------------------------------------------------------------------------\n * loadSoundsDirective.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nfunction loadSamples($http, supportedAudioFormats) {\n  var serverBaseURL = \"http://localhost:4500\";\n  return {\n    restrict: 'AE',\n    replace: 'false',\n    // scope: {\n    //     samplesData: \"=\"\n    // },\n    templateUrl: \"app/directives/templates/loadSamples.html\",\n    link: function link(scope, elem, attrs) {\n      /*\n       * ---------------------------------------------------------------------------------------\n       * styles & widgets\n       * ---------------------------------------------------------------------------------------\n       */\n      function initUI() {\n        $(\".samples-accordion\").accordion({\n          animate: 200,\n          collapsible: true,\n          active: false,\n          heightStyle: \"content\"\n        });\n        elem.find('button[name=\"playSampleButton\"]').button({\n          icon: \"ui-icon-circle-triangle-e\",\n          showLabel: false\n        });\n        elem.find('button[name=\"loadSampleButton\"]').button({\n          icon: \"ui-icon-check\",\n          showLabel: false\n        });\n        elem.find('button[id=\"samplesCancelBtn\"]').button();\n        elem.css(\"display\", \"block\");\n        scope.disableLoadingSpinner();\n      }\n      /*\n       * ---------------------------------------------------------------------------------------\n       * event listeners\n       * ---------------------------------------------------------------------------------------\n       */\n\n\n      function addEvents() {}\n      /*\n       * ---------------------------------------------------------------------------------------\n       * functions\n       * ---------------------------------------------------------------------------------------\n       */\n\n\n      scope.close = function () {\n        $(\"#angularView\").css(\"display\", \"block\");\n        elem.remove();\n      };\n\n      scope.playSampleFromServer = function (sample) {\n        if (!sample) return;\n\n        if (scope.samplesBuffers.hasOwnProperty(sample.path)) {\n          var buffer = scope.samplesBuffers[sample.path];\n          scope.playSoundFromBuffer(buffer);\n        } else {\n          scope.audioLoader(scope.audioContext, sample.path).then(function (buffer) {\n            scope.samplesBuffers[sample.path] = buffer;\n            scope.playSoundFromBuffer(buffer);\n          });\n        }\n      };\n\n      scope.loadSampleOnTrack = function (sample) {\n        if (!sample) return;\n        (0, _audioLoader.getArrayBuffer)(scope.audioContext, sample.path).then(function (arrayBuffer) {\n          scope.track.setSampleData(sample.name, arrayBuffer);\n          scope.close();\n        });\n      };\n      /*\n       * ---------------------------------------------------------------------------------------\n       * init\n       * ---------------------------------------------------------------------------------------\n       */\n\n\n      function init() {\n        // hide content behind\n        $(\"#angularView\").css(\"display\", \"none\");\n        var intervalID = setInterval(function () {\n          var result = $(\".samples-accordion\");\n\n          if (result.length > 0) {\n            clearInterval(intervalID);\n            initUI();\n            addEvents();\n          }\n        }, 200);\n      }\n\n      init();\n    }\n  };\n}\n\n},{\"../audio/audio-loader\":6}],12:[function(require,module,exports){\n/**\n * ---------------------------------------------------------------------------------------\n * savePresetDirective.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.savePresetDirective = savePresetDirective;\n\nfunction savePresetDirective() {\n  return {\n    restrict: 'AE',\n    replace: 'false',\n    templateUrl: \"app/directives/templates/savePreset.html\",\n    link: function link(scope, elem, attrs) {\n      scope.tagHandler = function (tag) {\n        return null;\n      };\n\n      scope.invalidPresetNameMessage = \"Choose a preset name (4-24 characters)\";\n      scope.invalidCategoryMessage = \"Choose a category\";\n\n      function initUI() {\n        $(\"#presetCancelBtn\").button();\n        $(\"#presetSaveBtn\").button();\n      }\n      /**\n       * ---------------------------------------------------------------------------------------\n       * init\n       * ---------------------------------------------------------------------------------------\n       */\n\n\n      initUI();\n    }\n  };\n}\n\n},{}],13:[function(require,module,exports){\n/**\n * ---------------------------------------------------------------------------------------\n * tickSliderDirective.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tickSliderDirective = tickSliderDirective;\n\nfunction tickSliderDirective() {\n  return {\n    restrict: 'AE',\n    replace: 'false',\n    scope: {\n      tick: \"=\",\n      ticksElements: \"=\",\n      resizeTick: \"=\"\n    },\n    link: function link(scope, elem, attrs) {\n      // console.log(scope.tick);\n      scope.ticksElements.push(elem);\n      elem.slider({\n        min: 0,\n        max: 100,\n        orientation: \"vertical\",\n        value: scope.tick.active ? scope.tick.volume * 100 : 0,\n        slide: function slide(event, ui) {\n          if (ui.value === 0) {\n            scope.tick.active = false;\n          } else {\n            scope.tick.active = true;\n          }\n\n          scope.tick.volume = ui.value * 0.01; // console.log(scope.tick.volume);\n        }\n      }).draggable(); // scope.resizeTick(elem);\n    }\n  };\n}\n\n},{}],14:[function(require,module,exports){\n/**\n * ---------------------------------------------------------------------------------------\n * trackDirective\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.trackDirective = trackDirective;\n\nvar _utils = require(\"../utils/utils\");\n\nfunction trackDirective($http, $compile, supportedAudioFormats) {\n  return {\n    restrict: 'AE',\n    replace: 'false',\n    scope: {\n      track: \"=\",\n      ticksElements: \"=\",\n      samplesData: \"=\",\n      samplesBuffers: \"=\",\n      removeTrack: \"=\",\n      audioContext: \"=\",\n      audioLoader: \"=\",\n      playSoundFromBuffer: \"=\",\n      enableLoadingSpinner: \"=\",\n      disableLoadingSpinner: \"=\"\n    },\n    templateUrl: \"app/directives/templates/trackDirective.html\",\n    link: function link(scope, elem, attrs) {\n      var serverBaseURL = \"http://localhost:4500\";\n      scope.resizeTick = resizeTick;\n      scope.handleFiles = handleFiles;\n      scope.playSound = playSound;\n      scope.onSoloTrack = onSoloTrack;\n      scope.onMuteTrack = onMuteTrack;\n      scope.loadSamplesFromServer = loadSamplesFromServer;\n      /*\n       * ---------------------------------------------------------------------------------------\n       * styles & widgets\n       * ---------------------------------------------------------------------------------------\n       */\n\n      elem.find('button[name=\"removeTrackButton\"]').button({\n        icon: \"ui-icon-close\",\n        showLabel: false\n      });\n      elem.find('button[name=\"playSoundButton\"]').button({\n        icon: \"ui-icon-circle-triangle-e\",\n        showLabel: false\n      });\n      elem.find('button[name=\"loadSoundFromServerBtn\"]').button();\n      elem.find('div[id=\"trackVolumeSlider\"]').slider({\n        min: 0,\n        max: 100,\n        orientation: \"horizontal\",\n        value: scope.track.gainNode.gain.value * 100,\n        slide: function slide(event, ui) {\n          scope.track.gainNode.gain.value = ui.value * 0.01;\n        }\n      }).draggable();\n\n      if (scope.track.pannerNodeSupported) {\n        elem.find('div[id=\"trackPanSlider\"]').slider({\n          min: -100,\n          max: 100,\n          orientation: \"horizontal\",\n          value: scope.track.pannerNode.pan.value * 100,\n          slide: function slide(event, ui) {\n            scope.track.pannerNode.pan.value = ui.value * 0.01;\n          }\n        }).draggable();\n      } else {\n        elem.find('div[id=\"trackPanSlider\"]').remove();\n        elem.find(\".pan-label\").remove(); // push down volume slider\n\n        elem.find('div[id=\"trackVolumeSlider\"]').css({// marginTop: 0,\n          // position: \"relative\",\n          // bottom: 0\n        });\n      }\n\n      elem.find('button[name=\"soloTrackButton\"]').button();\n      elem.find('button[name=\"muteTrackButton\"]').button();\n      elem.find('button[name=\"loadSoundFromServerBtn\"]').button({\n        showLabel: false,\n        icon: \"ui-icon-volume-on\"\n      });\n      /*\n       * ---------------------------------------------------------------------------------------\n       * event listeners\n       * ---------------------------------------------------------------------------------------\n       */\n\n      scope.$on(\"$destroy\", function () {\n        elem.unbind(\"dragover\", onDragOver);\n        elem.unbind(\"drop\", onDrop);\n        elem.unbind(\"dragleave\", onDragLeave);\n      });\n      elem.on(\"dragover\", onDragOver);\n      elem.on(\"drop\", onDrop);\n      elem.on(\"dragleave\", onDragLeave);\n      /*\n       * ---------------------------------------------------------------------------------------\n       * private functions\n       * ---------------------------------------------------------------------------------------\n       */\n\n      function resizeTick(tickElem) {\n        var ticksContainerWidth = elem.find(\".ticks-container\").width();\n        console.log(ticksContainerWidth);\n        var margin = 8;\n        var tickWidth = Math.floor((ticksContainerWidth - 15 * margin) / 16.0); // tickElem.css({\n        //     width: 32,\n        //     marginRight: \"8px !important\"\n        // });\n        // tickElem.parent().css({\n        //     width: tickWidth,\n        //     marginRight: margin\n        // });\n        // tickElem.find(\".ui-slider-handle\").css({\n        //\n        // });\n      }\n\n      function handleFiles(files) {\n        if (!files || files.length < 1) return;\n        var file = files[0];\n        var fileExtension = (0, _utils.getFileExtension)(file.name); // chech if it is an audio file with a supported extension\n\n        if (!supportedAudioFormats.has(fileExtension)) {\n          console.log(\"File format not supported by Web Audio API: \", fileExtension);\n          return;\n        }\n\n        var reader = new FileReader();\n\n        reader.onload = function (ev) {\n          var arrayBuffer = ev.target.result;\n          scope.track.setSampleData(file.name, arrayBuffer);\n        };\n\n        reader.readAsArrayBuffer(file);\n      }\n\n      function onDragOver(e) {\n        if (!elem.hasClass(\"track-dragfile\")) {\n          elem.addClass(\"track-dragfile\");\n        }\n\n        e.stopPropagation();\n        e.preventDefault();\n      }\n\n      function onDrop(e) {\n        e.stopPropagation();\n        e.preventDefault();\n        handleFiles(e.originalEvent.dataTransfer.files);\n        onDragLeave();\n      }\n\n      function onDragLeave(e) {\n        if (elem.hasClass(\"track-dragfile\")) {\n          elem.removeClass(\"track-dragfile\");\n        }\n\n        if (e) {\n          e.stopPropagation();\n          e.preventDefault();\n        }\n      }\n\n      function playSound() {\n        scope.track.playLoadedSample();\n      }\n\n      function onSoloTrack() {\n        scope.track.drumMachine.soloTrack(scope.track.id);\n      }\n\n      function onMuteTrack() {\n        scope.track.drumMachine.muteTrack(scope.track.id);\n      }\n\n      function loadSamplesFromServer() {\n        scope.enableLoadingSpinner();\n        $http({\n          url: serverBaseURL + \"/api/samples\",\n          method: \"GET\",\n          headers: {\n            \"Accept\": \"application/json\"\n          }\n        }).then(function (response) {\n          scope.samplesData = response.data;\n          var loadSamplesElem = $('<load-samples></load-samples>');\n          var el = $compile(loadSamplesElem)(scope);\n          $(\"body\").append(el);\n        });\n      }\n    }\n  };\n}\n\n},{\"../utils/utils\":16}],15:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initRoutes = initRoutes;\n\n/*\n * ---------------------------------------------------------------------------------------\n * routes.js\n * ---------------------------------------------------------------------------------------\n */\nfunction initRoutes($routeProvider) {\n  $routeProvider.when('/', {\n    controller: \"drumMachineController\",\n    templateUrl: \"app/components/drum-machine/drumMachineView.html\"\n  });\n  $routeProvider.when('/test', {\n    controller: \"testController\",\n    templateUrl: \"app/components/test/testView.html\"\n  });\n  $routeProvider.otherwise({\n    redirectTo: '/'\n  });\n}\n\n},{}],16:[function(require,module,exports){\n/*\n * ---------------------------------------------------------------------------------------\n * utils.js\n * ---------------------------------------------------------------------------------------\n */\n\"use strict\";\n/*\n * checkIfiOSdevice\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkIfiOSdevice = checkIfiOSdevice;\nexports.guid = guid;\nexports.getExtensionFromFileName = getExtensionFromFileName;\nexports.getFileNameFromPath = getFileNameFromPath;\nexports.getArrayAudioBufferFromUrl = getArrayAudioBufferFromUrl;\nexports.getFileExtension = getFileExtension;\n\nfunction checkIfiOSdevice() {\n  return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n}\n/*\n * generate uuid\n */\n\n\nfunction guid() {\n  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r = Math.random() * 16 | 0,\n        v = c == 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n  return uuid;\n}\n\nfunction getExtensionFromFileName(fileName) {\n  var re = /(?:\\.([^.]+))?$/;\n  var ext = re.exec(fileName)[1];\n  return ext;\n}\n\nfunction getFileNameFromPath(path) {\n  return path.replace(/^.*[\\\\\\/]/, '');\n}\n\nfunction getArrayAudioBufferFromUrl(audioCtx, url) {\n  return new Promise(function (resolve, reject) {\n    if (!audioCtx) {\n      reject(\"Missing audio context parameter.\");\n      return;\n    }\n\n    if (!url) {\n      reject(\"Missing url parameter\");\n      return;\n    }\n\n    var xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n    xhr.responseType = \"arraybuffer\";\n\n    xhr.onload = function () {\n      resolve(xhr.response);\n    };\n\n    xhr.send();\n  });\n}\n\nfunction getFileExtension(fileName) {\n  return fileName.substr(fileName.lastIndexOf('.') + 1);\n}\n\n},{}]},{},[2]);\n"],"file":"app.bundle.min.js"}